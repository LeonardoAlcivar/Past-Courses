<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Lab 08: BSTree: BSTree&lt; DataType, KeyType &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Lab 08: BSTree
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">BSTree&lt; DataType, KeyType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="BSTree" -->
<p><code>#include &lt;<a class="el" href="_b_s_tree_8h_source.html">BSTree.h</a>&gt;</code></p>

<p><a href="class_b_s_tree-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a4513fc6697f5e51bff8e7c448b446c9e">BSTree</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a6658391c178cb35858c9c465e1839fb0">BSTree</a> (const <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt; &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_tree.html">BSTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ac36b0b564aa3c411c239d730f506f448">operator=</a> (const <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt; &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a968c51c539f4ae41357c78b6a60fea4c">~BSTree</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a926822d08f3d0321603f9fafd2254b16">clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ab86b4cea496ee53076021126423d51fd">insert</a> (const DataType &amp;newDataItem)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a755549f7b88d0178a96ca84afd5e04cf">remove</a> (const KeyType &amp;deleteKey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a43768375369ca8fe641a86451997ad45">isEmpty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a3850adc6b8ae965ec11ec0e0567b6f7d">getHeight</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a880d98553153533d3c29504e8a272c7d">getCount</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a4359bfee390669b5adaf0380ef62b18d">retrieve</a> (const KeyType &amp;searchKey, DataType &amp;searchDataItem) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ac28277cacbf8ab33326473a419abf097">showStructure</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a7f08f48e6d1bbe3eb726856a947325e7">writeKeys</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a92079e5301185f41eebe1c32c2357258">writeLessThan</a> (const KeyType &amp;searchKey) const </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#afde91fa451ee2bfccb29a83dc73856c5">clone_sub</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;currentNode, const <a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *otherNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ac1afa7d8d954f58664c3ad4765ee01d2">clear_sub</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;currentNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a9b49fb07e0b7f42ae5e9476356554176">insert_sub</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;currentNode, const DataType &amp;newDataItem, const KeyType &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ad55ac383f8663423ceef8ddb2ea9758b">remove_sub</a> (const KeyType &amp;deleteKey, <a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;currentNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a3b5acf5303ea40326546b6b14ca3837c">getHeight_sub</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *currentNode) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a73594cb9555a1ce6d2146f213e654da8">getCount_sub</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *currentNode) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#af9cc2368aa083c472ac701fd20dde36e">retrieve_sub</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *currentNode, const KeyType &amp;searchKey, DataType &amp;searchDataItem) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a44b3002e3476eb410468a4b9aaaa73ef">showHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *p, int level) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a1762a56d5bfc2164566156605cf98f36">writeKeys_sub</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *currentNode) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a86e2419aa9bba28935b22d5c94822c29">writeLessThan_sub</a> (KeyType &amp;searchKey, <a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *start, <a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *predecessor, bool &amp;keysWerePrinted) const </td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a83534afce9094181ac031f9f596a8625">root</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename DataType, typename KeyType&gt;<br/>
class BSTree&lt; DataType, KeyType &gt;</h3>

<p>The class implementations of the Binary Search Tree ADT. This class offers all basic functionality of the Binary Search Tree. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4513fc6697f5e51bff8e7c448b446c9e"></a><!-- doxytag: member="BSTree::BSTree" ref="a4513fc6697f5e51bff8e7c448b446c9e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html">BSTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="class_b_s_tree.html">BSTree</a></p>
<p>The default constructor for the Binary Search Tree ADT. Constructs an empty tree.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a tree with the calling identifier has not yet been instantiated</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>an empty tree with the calling identifier will have been created</li>
</ol>
</dd></dl>
<ol type="1">
<li>BSTreeNode* root data member is set to NULL</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a6658391c178cb35858c9c465e1839fb0"></a><!-- doxytag: member="BSTree::BSTree" ref="a6658391c178cb35858c9c465e1839fb0" args="(const BSTree&lt; DataType, KeyType &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html">BSTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="class_b_s_tree.html">BSTree</a></p>
<p>The copy constructor for the Binary Search Tree ADT. Constructs a clone of the given other tree.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another binary search tree object of similar types</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a tree with the calling identifier has not yet been created</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>a tree that is a clone of the given other tree has been created</li>
</ol>
</dd></dl>
<ol type="1">
<li>BSTree* root data member is set to NULL</li>
<li>the overloaded operator= is called</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a968c51c539f4ae41357c78b6a60fea4c"></a><!-- doxytag: member="BSTree::~BSTree" ref="a968c51c539f4ae41357c78b6a60fea4c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::~<a class="el" href="class_b_s_tree.html">BSTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>~BSTree</p>
<p>The destructor for the Binary Search Tree ADT. Ensures all dynamically allocated memory is returned.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a tree with the calling identifier has been instantiated</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>*this tree will be destructed properly, returning all dynamically allocated memory</li>
</ol>
</dd></dl>
<ol type="1">
<li>calls the clear function to delete all nodes contained in the tree</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a926822d08f3d0321603f9fafd2254b16"></a><!-- doxytag: member="BSTree::clear" ref="a926822d08f3d0321603f9fafd2254b16" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a926822d08f3d0321603f9fafd2254b16">clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>clear</p>
<p>Clears all data from the <a class="el" href="class_b_s_tree.html">BSTree</a>.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> object has been instantiated</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>all data will be removed from the tree</li>
<li>all dynamic memory will be returned</li>
<li>the the value of the BSTreeNode* root data member will be NULL</li>
</ol>
</dd></dl>
<ol type="1">
<li>if the tree has contents the clear_sub private helper function is called with the BSTreeNode* root data member as a parameter in order to clear the entire tree</li>
<li>if the tree is empty, no further action is taken</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="ac1afa7d8d954f58664c3ad4765ee01d2"></a><!-- doxytag: member="BSTree::clear_sub" ref="ac1afa7d8d954f58664c3ad4765ee01d2" args="(BSTreeNode *&amp;currentNode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#ac1afa7d8d954f58664c3ad4765ee01d2">clear_sub</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>currentNode</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>clear_sub</p>
<p>The private helper function that carries out the clearing of the tree. This fucntion clears a given subtree by clearing the left and right subtrees and then deleting the current node (post-order traversal). Ensures all dynamic memory is returned for the given tree.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">currentNode</td><td>the node currently being considered by the function</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> has been instantiated</li>
<li>the clear_sub function is called using a pointer that points to valid data</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>the <a class="el" href="class_b_s_tree.html">BSTree</a> subtrees will be empty</li>
<li>the BSTreeNode* currentNode will point to NULL</li>
</ol>
</dd></dl>
<ol type="1">
<li>each branch pointer is checked to see if it points to data</li>
<li>if the branch pointers point to valid subtrees, these are cleared</li>
<li>once any subtrees are cleared, the currentNode is deleted</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="afde91fa451ee2bfccb29a83dc73856c5"></a><!-- doxytag: member="BSTree::clone_sub" ref="afde91fa451ee2bfccb29a83dc73856c5" args="(BSTreeNode *&amp;currentNode, const BSTreeNode *otherNode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#afde91fa451ee2bfccb29a83dc73856c5">clone_sub</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>currentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>otherNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>clone_sub</p>
<p>The private helper function that carries out a cloning operation by recursively following the nodes of a given <a class="el" href="class_b_s_tree.html">BSTree</a> of same type and duplicating its nodes using an in-order traversal.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">currentNode</td><td>the node currently being considered by the function </td></tr>
    <tr><td class="paramname">otherNode</td><td>the counterpart node in the other tree that is being cloned</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> has been, or is being, instantiated</li>
<li>the clone_sub function has been called using a node pointer within the tree that points to NULL</li>
<li>the BSTreeNode* otherNode must point to valid data</li>
<li>other recursive calls previous to this one may have been made</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>BSTreeNode* currentNode will point to an equivalent object to the one poined by BSTreeNode* otherNode</li>
<li>recursive calls will be made to continue the process down to the leaves of the tree</li>
</ol>
</dd></dl>
<ol type="1">
<li>a new <a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> is created with BSTreeNode* currentNode and given a copy of the dataItem held by other, the left and right pointers are set to NULL</li>
<li>checks are made to see if otherNode's left and right pointers are NULL or not</li>
<li>the function is called again to clone the other tree's left and right subtrees if possible</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a880d98553153533d3c29504e8a272c7d"></a><!-- doxytag: member="BSTree::getCount" ref="a880d98553153533d3c29504e8a272c7d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a880d98553153533d3c29504e8a272c7d">getCount</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getCount</p>
<p>Provides public access to find the current count of items stored in the the <a class="el" href="class_b_s_tree.html">BSTree</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int count the count of items in the tree</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> object has been instantiated</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>the <a class="el" href="class_b_s_tree.html">BSTree</a> remains unchanged</li>
<li>the current size of the tree is returned</li>
</ol>
</dd></dl>
<ol type="1">
<li>the getCount_sub helper is called, starting at the root, to trace the tree and count the nodes</li>
<li>the value returned by the helper function is the size of the tree</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a73594cb9555a1ce6d2146f213e654da8"></a><!-- doxytag: member="BSTree::getCount_sub" ref="a73594cb9555a1ce6d2146f213e654da8" args="(BSTreeNode *currentNode) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a73594cb9555a1ce6d2146f213e654da8">getCount_sub</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>currentNode</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getHeight_sub</p>
<p>The private helper function that counts all nodes in the current tree.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">currentNode</td><td>the node currently being considered by the function</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> has been instantiated</li>
<li>this function may have been called previously</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>every valid node in the tree will be visited</li>
<li>the count of nodes in the subtree evaluated by the function is returned</li>
</ol>
</dd></dl>
<ol type="1">
<li></li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a3850adc6b8ae965ec11ec0e0567b6f7d"></a><!-- doxytag: member="BSTree::getHeight" ref="a3850adc6b8ae965ec11ec0e0567b6f7d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a3850adc6b8ae965ec11ec0e0567b6f7d">getHeight</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getHeight</p>
<p>Provides public access to find the current height of the <a class="el" href="class_b_s_tree.html">BSTree</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int height the height of the tree, that is, the number of vertices in the longest chain in the tree</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> object has been instantiated</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>the <a class="el" href="class_b_s_tree.html">BSTree</a> remains unchanged</li>
<li>the current height of the tree is returned</li>
</ol>
</dd></dl>
<ol type="1">
<li>the getHeight_sub helper is called, starting at the root, to trace the longest chain in the tree</li>
<li>the value returned by the helper function is the height of the tree</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a3b5acf5303ea40326546b6b14ca3837c"></a><!-- doxytag: member="BSTree::getHeight_sub" ref="a3b5acf5303ea40326546b6b14ca3837c" args="(BSTreeNode *currentNode) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a3b5acf5303ea40326546b6b14ca3837c">getHeight_sub</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>currentNode</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getHeight_sub</p>
<p>The private helper function that determines the height of the tree by counting the vertices of the maximum length chain.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">currentNode</td><td>the node currently being considered by the function </td></tr>
    <tr><td class="paramname">level</td><td>the level a node pointed by currentNode would be on</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int height the height of the subtree including currentNode</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> has been instantiated</li>
<li>this function may have been called previously</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>every chain in the train will have been followed in order to count the maximum length chain</li>
</ol>
</dd></dl>
<ol type="1">
<li>if BSTreeNode* currentNode points to NULL, the value of level - 1 is returned (base case)</li>
<li>otherwise, the function is called to trace its subtrees to continue counting the tree height</li>
<li>the subtree heights are compared to find the greatest one</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="ab86b4cea496ee53076021126423d51fd"></a><!-- doxytag: member="BSTree::insert" ref="ab86b4cea496ee53076021126423d51fd" args="(const DataType &amp;newDataItem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#ab86b4cea496ee53076021126423d51fd">insert</a> </td>
          <td>(</td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>newDataItem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>insert</p>
<p>Inserts newDataItem into the tree according to the items key. If a data item with the same key already exists in the tree, then it is replaced with newDataItem. Otherwise, a node is created in the appropriate place in the tree to accomodate newDataItem.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newDataItem</td><td>an object of type DataItem to be inserted into the tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> object has been instantiated</li>
<li>the data type of the templated <a class="el" href="class_b_s_tree.html">BSTree</a> supports a getKey() member</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>the tree will contain a <a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> containing newDataItem, appropriately located relative to the pre-existing nodes</li>
</ol>
</dd></dl>
<ol type="1">
<li>the key of the data item is obtained</li>
<li>the insert_sub helper is called, starting at the root, to locate the correct insertion location for the newDataItem</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a9b49fb07e0b7f42ae5e9476356554176"></a><!-- doxytag: member="BSTree::insert_sub" ref="a9b49fb07e0b7f42ae5e9476356554176" args="(BSTreeNode *&amp;currentNode, const DataType &amp;newDataItem, const KeyType &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a9b49fb07e0b7f42ae5e9476356554176">insert_sub</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>currentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>newDataItem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>insert_sub</p>
<p>The private helper function that inserts new data into the tree. If a node containing a data item with a key equivalent to the given one, then the data is replaced with the given data. If no match for the given key exists in the tree, a new node is created to accomodate the data.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">currentNode</td><td>the node currently being considered by the function </td></tr>
    <tr><td class="paramname">newDataItem</td><td>the data item to be inserted in the tree </td></tr>
    <tr><td class="paramname">key</td><td>the key of the item to be inserted</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> has been instantiated</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>if there is a node with a key equivalent to the given one, then its data is replaced with DataType neDataItem</li>
<li>if there is no matching key, a new node is created in the appropriate position of the tree to accommodate newDataItem</li>
</ol>
</dd></dl>
<ol type="1">
<li>if the BSTreeNode* points to NULL, a new node is created and given the data of DataType newDataItem</li>
<li>otherwise, a check is made to see if it contains an equivalent key to the given one, if so, the data replacement operation is conducted</li>
<li>if the keys still don't match, checks to see which subtree the data with the given key belongs in, and the helper function is called to insert the data in the appropriate subtree</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a43768375369ca8fe641a86451997ad45"></a><!-- doxytag: member="BSTree::isEmpty" ref="a43768375369ca8fe641a86451997ad45" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a43768375369ca8fe641a86451997ad45">isEmpty</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>isEmtpy</p>
<p>Reports the state of the tree, specifically, returns true if the <a class="el" href="class_b_s_tree.html">BSTree</a> is empty, and false if the tree has any contents.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool empty the truth value of the <a class="el" href="class_b_s_tree.html">BSTree</a> containing no nodes</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> object has been instantiated</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>the <a class="el" href="class_b_s_tree.html">BSTree</a> remains unchanged</li>
<li>the state of the tree is indicated via the return of a boolean flag</li>
</ol>
</dd></dl>
<ol type="1">
<li>the remove_sub helper is called, starting at the root, to locate the given key, if possible, and remove the node</li>
<li>if a removal occured true is returned, otherwise false is returned</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="ac36b0b564aa3c411c239d730f506f448"></a><!-- doxytag: member="BSTree::operator=" ref="ac36b0b564aa3c411c239d730f506f448" args="(const BSTree&lt; DataType, KeyType &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt; &amp; <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>operator=</p>
<p>The overloaded assignment operator. Assigns a clone of <a class="el" href="class_b_s_tree.html">BSTree</a> other to *this.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another binary search tree of similar type</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>*this</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a tree with the calling identifier has been or is being created</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>a tree that is a clone of the given other tree has been created</li>
<li>a reference to the new *this is returned</li>
</ol>
</dd></dl>
<ol type="1">
<li>a check to see if *this is being assigned to itself is performed</li>
<li>otherwise *this is cleared</li>
<li>if <a class="el" href="class_b_s_tree.html">BSTree</a> other is not empty, the clone_sub private helper function is called to carry out the cloning process</li>
<li>if <a class="el" href="class_b_s_tree.html">BSTree</a> other is empty, no further action is taken</li>
<li>a reference to *this is returned</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a755549f7b88d0178a96ca84afd5e04cf"></a><!-- doxytag: member="BSTree::remove" ref="a755549f7b88d0178a96ca84afd5e04cf" args="(const KeyType &amp;deleteKey)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a755549f7b88d0178a96ca84afd5e04cf">remove</a> </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>deleteKey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>remove</p>
<p>Removes a node with the given key from the tree. Returns the success of the removal operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">deleteKey</td><td>the key used to locate the item to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> object has been instantiated</li>
<li>the data type of the templated <a class="el" href="class_b_s_tree.html">BSTree</a> supports a getKey() member</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>if it exists, the node containing the data item with the given key will be removed</li>
<li>the success of the operation is returned to the calling function</li>
</ol>
</dd></dl>
<ol type="1">
<li>the remove_sub helper is called, starting at the root, to locate the given key, if possible, and remove the node</li>
<li>if a removal occured true is returned, otherwise false is returned</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="ad55ac383f8663423ceef8ddb2ea9758b"></a><!-- doxytag: member="BSTree::remove_sub" ref="ad55ac383f8663423ceef8ddb2ea9758b" args="(const KeyType &amp;deleteKey, BSTreeNode *&amp;currentNode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#ad55ac383f8663423ceef8ddb2ea9758b">remove_sub</a> </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>deleteKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>currentNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>remove_sub</p>
<p>The private helper function used to delete data from the tree. In general, this function performs similar to a remove function in a linked list. In the case that a node to be removed has two children, the node is replaced with its "in-order predecessor."</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">deleteKey</td><td>fad </td></tr>
    <tr><td class="paramname">currentNode</td><td>the pointer that points to the node currently being considered. Note: this parameter is passed by reference, so it is actually the pointer belonging to the node's predecessor (or the root data member).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool removed a flag to indicate whether or not a node was located and removed (true for removal, false for failure to remove)</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> has been instantiated</li>
<li>BSTreeNod* currentNode points to the current location of the tree being considered currently</li>
<li>recursive calls to this function may have been made previously</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>if a node containing data with a key equivalent to KeyType searchKey is found, it is removed in an appropriate manner and true is returned</li>
<li>otherwise, nothing occurs and false is returned</li>
<li>there are no guarantees as to the relative structure of the tree other than the tree will still fit the definition of a binary search tree</li>
</ol>
</dd></dl>
<ol type="1">
<li>a search for a key equivalent to KeyType searchKey is conducted</li>
<li>if the function is called on a NULL pointer, then the search has failed, no removal can be performed, and false is returned</li>
<li>if the key matches a leaf, then the leaf is simply deleted</li>
<li>if the key matches a node with one child, then the tree is simply re-linked and the BSTreeNode* currentNode is linked to the appropriate child, and the excluded node is deleted</li>
<li>if the key matches a node with 2 children, then the "in-order predecessor" of the node is found, and the original node's data is replaced with that of the predecessor, and the now reduntant predecessor node is then deleted</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a4359bfee390669b5adaf0380ef62b18d"></a><!-- doxytag: member="BSTree::retrieve" ref="a4359bfee390669b5adaf0380ef62b18d" args="(const KeyType &amp;searchKey, DataType &amp;searchDataItem) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a4359bfee390669b5adaf0380ef62b18d">retrieve</a> </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>searchKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataType &amp;&#160;</td>
          <td class="paramname"><em>searchDataItem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>retrieve</p>
<p>Provides public access to find the item of the given key stored in the tree. The success of the operation is returned, while searchDataItem is modified by reference. If the operation fails, searchDataItem is left unchanged.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">searchKey</td><td>the key corresponding to the sought item </td></tr>
    <tr><td class="paramname">searchDataItem</td><td>the reference variable used to store the sought item if found</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool found the sucess in finding the sought item with the given key</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> object has been instantiated</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>the <a class="el" href="class_b_s_tree.html">BSTree</a> remains unchanged</li>
<li>the data item with the given key is passed back by reference if found</li>
<li>the truth value of whether or not the sought item was found</li>
</ol>
</dd></dl>
<ol type="1">
<li>the retrieve_sub helper is called to search the tree for the item with the given key</li>
<li>if the given key is found, the DataType searchDataItem passed by reference will be given the value of the item with the sought key</li>
<li>if the item with the given key was found, true is returned, otherwise false is returned</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="af9cc2368aa083c472ac701fd20dde36e"></a><!-- doxytag: member="BSTree::retrieve_sub" ref="af9cc2368aa083c472ac701fd20dde36e" args="(BSTreeNode *currentNode, const KeyType &amp;searchKey, DataType &amp;searchDataItem) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#af9cc2368aa083c472ac701fd20dde36e">retrieve_sub</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>currentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>searchKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataType &amp;&#160;</td>
          <td class="paramname"><em>searchDataItem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>retrieve_sub</p>
<p>The private helper function that counts all nodes in the current tree.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">currentNode</td><td>the node currently being considered by the function</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> has been instantiated</li>
<li>this function may have been called previously</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>if the item with the given key is found, it is passed back by reference in the DataType searchDataItem, otherwise it is left unmodified and false is returned</li>
<li>the <a class="el" href="class_b_s_tree.html">BSTree</a> remains unchanged</li>
</ol>
</dd></dl>
<ol type="1">
<li>if the item with the given key is found, it is passed back by reference and true is returned to indicate that the item was found</li>
<li>if the function is called with a NULL pointer, the item was not found, DataType searchDataItem is not modified, and true is returned</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a44b3002e3476eb410468a4b9aaaa73ef"></a><!-- doxytag: member="BSTree::showHelper" ref="a44b3002e3476eb410468a4b9aaaa73ef" args="(BSTreeNode *p, int level) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a44b3002e3476eb410468a4b9aaaa73ef">showHelper</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>showHelper</p>
<p>The private helper function that works to output the contents of the tree to the screen.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a pointer to the node currently being considered </td></tr>
    <tr><td class="paramname">level</td><td>the level of the nodes to be output by this function call</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> has been instantiated</li>
<li>this function may have been called previously</li>
<li>the DataType must support the &lt;&lt; operator</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>the tree will remain unchanged</li>
<li>the contents of the given subtree will be displayed on the screen</li>
</ol>
</dd></dl>
<ol type="1">
<li></li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="ac28277cacbf8ab33326473a419abf097"></a><!-- doxytag: member="BSTree::showStructure" ref="ac28277cacbf8ab33326473a419abf097" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#ac28277cacbf8ab33326473a419abf097">showStructure</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>showStructure</p>
<p>Outputs the keys in a binary search tree. The tree is output rotated counterclockwise 90 degrees from its conventional orientation using a "reverse" inorder traversal. This operation is intended for testing and debugging purposes only.</p>
<p>PROVIDED BY THE LAB MANUAL PACKAGE</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> object has been instantiated</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>the <a class="el" href="class_b_s_tree.html">BSTree</a> remains unchanged</li>
<li>the structure of the tree is displayed on the screen</li>
</ol>
</dd></dl>
<ol type="1">
<li>the showHelper function is called to display the tree, starting from the root</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a7f08f48e6d1bbe3eb726856a947325e7"></a><!-- doxytag: member="BSTree::writeKeys" ref="a7f08f48e6d1bbe3eb726856a947325e7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a7f08f48e6d1bbe3eb726856a947325e7">writeKeys</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>writeKeys</p>
<p>Provides public access to have the keys currently contained in the tree listed in increasing order on the screen. The DataType used must support the &lt;&lt; operator.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> object has been instantiated</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>the <a class="el" href="class_b_s_tree.html">BSTree</a> remains unchanged</li>
<li>the keys of the data items will be listed in increasing order on the screen, separated by a space</li>
</ol>
</dd></dl>
<ol type="1">
<li>the writeKeys_sub helper function is called to carry out the process of displaying the keys, starting from the root</li>
<li>if the tree is empy, it is reported</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a1762a56d5bfc2164566156605cf98f36"></a><!-- doxytag: member="BSTree::writeKeys_sub" ref="a1762a56d5bfc2164566156605cf98f36" args="(BSTreeNode *currentNode) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a1762a56d5bfc2164566156605cf98f36">writeKeys_sub</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>currentNode</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>writeKeysSub</p>
<p>The private helper function that works to output all keys in ascending order for a given subtree.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">currentNode</td><td>a pointer to the node currently being considered</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> has been instantiated</li>
<li>BSTreeNode* currentNode must point to valid data</li>
<li>this function may have been called previously</li>
<li>the DataType must support the &lt;&lt; operator</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>the tree will remain unchanged</li>
<li>the keys of the given subtree will be listed on the screen</li>
</ol>
</dd></dl>
<ol type="1">
<li>a check to ensure the given pointer is not null is performed</li>
<li>all keys in the left subtree of the tree currently being considered are listed first</li>
<li>the key of the current node is listed</li>
<li>all keys of the right subtree of the tree currently being considered are then listed</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a92079e5301185f41eebe1c32c2357258"></a><!-- doxytag: member="BSTree::writeLessThan" ref="a92079e5301185f41eebe1c32c2357258" args="(const KeyType &amp;searchKey) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a92079e5301185f41eebe1c32c2357258">writeLessThan</a> </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>searchKey</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>writeLessThan</p>
<p>Provides public access to have the keys currently contained in the tree listed in increasing order up to the given bound on the screen. The DataType used must support the &lt;&lt; operator.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">searchKey</td><td>the upper bound of the keys to be listed. If this key is in the list, it is listed, otherwise the key nearest the given parameter is the larges key listed</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> object has been instantiated</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>the <a class="el" href="class_b_s_tree.html">BSTree</a> remains unchanged</li>
<li>the keys of the data items will be listed in increasing order on the screen, up to the upper bound, separated by a space</li>
</ol>
</dd></dl>
<ol type="1">
<li>the writeLessThan_sub helper is called to search the tree for the item with the given key, or the nearest one that is less than the given key, starting at the root</li>
<li>all keys less than and including the given bound KeyType searchKey are listed if they are present in the tree</li>
<li>if no such keys exist, this is reported.</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a86e2419aa9bba28935b22d5c94822c29"></a><!-- doxytag: member="BSTree::writeLessThan_sub" ref="a86e2419aa9bba28935b22d5c94822c29" args="(KeyType &amp;searchKey, BSTreeNode *start, BSTreeNode *predecessor, bool &amp;keysWerePrinted) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a86e2419aa9bba28935b22d5c94822c29">writeLessThan_sub</a> </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&#160;</td>
          <td class="paramname"><em>searchKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>predecessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>keysWerePrinted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>writeLessThan_sub</p>
<p>Lists all keys that are less than or equal to the given key (searchKey) on the screen.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">searchKey</td><td>the key given to indicate the upper (inclusive) bound for the keys to be printed </td></tr>
    <tr><td class="paramname">start</td><td>a pointer for the node to start at </td></tr>
    <tr><td class="paramname">predecessor</td><td>a pointer to the start node's predecessor, call with NULL if such a node does not exist </td></tr>
    <tr><td class="paramname">keysWerePrinted</td><td>a flag to be passed through all calls to indicate wether or not keys less than the search key have been found</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>a <a class="el" href="class_b_s_tree.html">BSTree</a> has been instantiated</li>
<li>BSTreeNode* start must point to valid data</li>
<li>BSTreeNode* predecessor must point to either a parent of start or contain the value NULL</li>
<li>previous recursive calls may have been made</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>the tree will remain unchanged</li>
<li>once all recursive calls have resolved, all keys less than KeyType searchKey will be written in ascending order to the screen</li>
</ol>
</dd></dl>
<ol type="1">
<li>the currentNode "cursor" is moved right as far as possible</li>
<li>with each move, the previous node and all nodes with keys less than it are listed</li>
<li>once the "cursor" has moved too far to the right, it is then moved left in an attempt to find more nodes with keys meeting the search criteria</li>
<li>a recursive call is made to repeat the process</li>
<li>the task completes when a call is made and no keys could be successfully printed (base case)</li>
<li>if no keys can be printed, this is indicated</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a83534afce9094181ac031f9f596a8625"></a><!-- doxytag: member="BSTree::root" ref="a83534afce9094181ac031f9f596a8625" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType, typename KeyType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a>* <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html#a83534afce9094181ac031f9f596a8625">root</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_b_s_tree_8h_source.html">BSTree.h</a></li>
<li><a class="el" href="_b_s_tree_8cpp.html">BSTree.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 30 2013 17:31:14 for Lab 08: BSTree by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
