<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Terence Henriod: WeightedGraph Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Terence Henriod
   
   </div>
   <div id="projectbrief">Lab 11: WeightedGraph</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">WeightedGraph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="WeightedGraph" -->
<p><code>#include &lt;<a class="el" href="_weighted_graph_8h_source.html">WeightedGraph.h</a>&gt;</code></p>

<p><a href="class_weighted_graph-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph_1_1_vertex.html">Vertex</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#a9255d382e53db8d520ef1e2b63814c81">WeightedGraph</a> (int maxNumber=<a class="el" href="class_weighted_graph.html#af9b34017e5b494cd3aca2dbc8335fc3c">MAX_GRAPH_SIZE</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#a294fd717db213e761dc0eb65bbfcb7ab">WeightedGraph</a> (const <a class="el" href="class_weighted_graph.html">WeightedGraph</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_weighted_graph.html">WeightedGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#aa5982a507e944af28e4749cdc06543c6">operator=</a> (const <a class="el" href="class_weighted_graph.html">WeightedGraph</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#ad7b4a5c8206772f9f4fb5906c0d64923">~WeightedGraph</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#aeaea1bd5b1e14b69f2155613bfd25d68">computePaths</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#aec4ef3455e3cc0d73a42e042adb7ac40">insertVertex</a> (const <a class="el" href="class_weighted_graph_1_1_vertex.html">Vertex</a> &amp;newVertex)  throw ( logic_error )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#a8be8442a104f3c411f6b1bb072fa97b1">insertEdge</a> (const string &amp;v1, const string &amp;v2, const int wt)  throw ( logic_error )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#a3afabc2236c99dac950f5161f715f114">retrieveVertex</a> (const string &amp;v, <a class="el" href="class_weighted_graph_1_1_vertex.html">Vertex</a> &amp;vData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#ab136044e7378313087be69eb43e7f042">getEdgeWeight</a> (const string &amp;v1, const string &amp;v2, int &amp;wt) const   throw ( logic_error )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#abaaa572a9b1a60ec3cd99d8db9d9590e">removeVertex</a> (const string &amp;v)  throw ( logic_error )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#a1db455249fa7fedf70aa5683487a17df">removeEdge</a> (const string &amp;v1, const string &amp;v2)  throw ( logic_error )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#a26890ebf74d23821a6e4dbcf803b5002">clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#a03884e32b9e093b10e3a44add7eaa928">areAllEven</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#a60be8bab10a9142846093cb768855efd">hasProperColoring</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#a1c03a0f68447cf88fed97c2076501702">isEmpty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#a22e56836e3967031a657cfa9ea5b9843">isFull</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#a8e6ea9adc87345052786eec67a5f9164">showShortestPaths</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#ad7f20a989073ea5401d504d944182347">showStructure</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#af9b34017e5b494cd3aca2dbc8335fc3c">MAX_GRAPH_SIZE</a> = 10</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#ab41b338adfc1ebc080cfca0e0b85de4b">INFINITE_EDGE_WT</a> = INT_MAX</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#aff499d450cb315d42d5bcff949f53141">NOT_FOUND</a> = -1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#abc512f95c7ebf26d8984bc686f0b7bd7">LOOP_COST</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#ad1854c7cf163167c7cebe7a2f5ebe9d6">DEFAULT_COLOR</a> = 'R'</td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#a9a7095848029a217a2360ca8f6fc6fc7">setEdge</a> (const int row, const int col, const int wt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#a68788bc02a44a33289411a0d3d1da85a">setPath</a> (const int row, const int col, const int cost)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#a8079a4fb184edefad85863d915e66e9e">getEdge</a> (const int row, const int col) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#a0c6d1c040128d1818ab3b38ff72723a4">getIndex</a> (const string &amp;v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#a8360fa50be8d2bc095b2ba69d02eb319">getPath</a> (const int row, const int col) const </td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#ae8cd4e7b91702a470e59472979e94cb5">maxSize</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#a4452835ad9619580ff968a4d6a9cfe44">size</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_weighted_graph_1_1_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#a0893fce457ff57820d30fd050777a058">vertexList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#aed50ef32c1c87bb10ca5d1bbc182880a">adjacencyMatrix</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_weighted_graph.html#ad2e0c787899af85ebf86e9c68431c9aa">pathMatrix</a></td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9255d382e53db8d520ef1e2b63814c81"></a><!-- doxytag: member="WeightedGraph::WeightedGraph" ref="a9255d382e53db8d520ef1e2b63814c81" args="(int maxNumber=MAX_GRAPH_SIZE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_weighted_graph.html#a9255d382e53db8d520ef1e2b63814c81">WeightedGraph::WeightedGraph</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxNumber</em> = <code><a class="el" href="class_weighted_graph.html#af9b34017e5b494cd3aca2dbc8335fc3c">MAX_GRAPH_SIZE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="class_weighted_graph.html">WeightedGraph</a></p>
<p>The default constructor for the <a class="el" href="class_weighted_graph.html">WeightedGraph</a> ADT. Initializes an empty graph of the given parameterized size.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">maxNumber</td><td>The number of vertices the <a class="el" href="class_weighted_graph.html">WeightedGraph</a> can contain when full. By default the value MAX_GRAPH_SIZE (defined in <a class="el" href="_weighted_graph_8h.html" title="Class declarations for the WeighedGraph ADT and the Vertex inner class. Utilizes both an adjacency ma...">WeightedGraph.h</a>)is given.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>There is available memory to instantiate a <a class="el" href="class_weighted_graph.html">WeightedGraph</a> object.</li>
<li>The <a class="el" href="class_weighted_graph.html">WeightedGraph</a> is given a valid identifier.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>An empty <a class="el" href="class_weighted_graph.html">WeightedGraph</a> object will be instantiated.</li>
</ol>
</dd></dl>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a294fd717db213e761dc0eb65bbfcb7ab"></a><!-- doxytag: member="WeightedGraph::WeightedGraph" ref="a294fd717db213e761dc0eb65bbfcb7ab" args="(const WeightedGraph &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_weighted_graph.html#a9255d382e53db8d520ef1e2b63814c81">WeightedGraph::WeightedGraph</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_weighted_graph.html">WeightedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="class_weighted_graph.html">WeightedGraph</a></p>
<p>The default constructor for the <a class="el" href="class_weighted_graph.html">WeightedGraph</a> ADT. Initializes an empty graph of the given parameterized size. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">maxNumber</td><td>The number of vertices the <a class="el" href="class_weighted_graph.html">WeightedGraph</a> can contain when full. By default the value MAX_GRAPH_SIZE (defined in <a class="el" href="_weighted_graph_8h.html" title="Class declarations for the WeighedGraph ADT and the Vertex inner class. Utilizes both an adjacency ma...">WeightedGraph.h</a>)is given.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>There is available memory to instantiate a <a class="el" href="class_weighted_graph.html">WeightedGraph</a> object.</li>
<li>The <a class="el" href="class_weighted_graph.html">WeightedGraph</a> is given a valid identifier.</li>
<li>Weightedgraph other is a valid instantiation of a <a class="el" href="class_weighted_graph.html">WeightedGraph</a> object.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>A <a class="el" href="class_weighted_graph.html">WeightedGraph</a> object equivalent to the given parameter <a class="el" href="class_weighted_graph.html">WeightedGraph</a> other will be instantiated.</li>
</ol>
</dd></dl>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="ad7b4a5c8206772f9f4fb5906c0d64923"></a><!-- doxytag: member="WeightedGraph::~WeightedGraph" ref="ad7b4a5c8206772f9f4fb5906c0d64923" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_weighted_graph.html#ad7b4a5c8206772f9f4fb5906c0d64923">WeightedGraph::~WeightedGraph</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="class_weighted_graph.html">WeightedGraph</a></p>
<p>The destructor for the <a class="el" href="class_weighted_graph.html">WeightedGraph</a> ADT. Ensures all dynamic memory is returned.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>*this was a properly instantiated <a class="el" href="class_weighted_graph.html">WeightedGraph</a> object.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>All dynamic memory will be returned.</li>
<li>*this will be destructed.</li>
</ol>
</dd></dl>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a03884e32b9e093b10e3a44add7eaa928"></a><!-- doxytag: member="WeightedGraph::areAllEven" ref="a03884e32b9e093b10e3a44add7eaa928" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_weighted_graph.html#a03884e32b9e093b10e3a44add7eaa928">WeightedGraph::areAllEven</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>areAllEven</p>
<p>Determines if each vertex in the graph has an even degree, and then returns true if each vertex does have an even degree and false otherwise.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>hasEulerianChain The truth value of whether or not the graph has all even degree vertices (also indicates if there is a closed chain that uses all paths once). true if all vertices do have even degree, false otherwise.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>*this is a valid instantiation of a <a class="el" href="class_weighted_graph.html">WeightedGraph</a>.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>The <a class="el" href="class_weighted_graph.html">WeightedGraph</a> will remain unchanged.</li>
<li>The truth of all verticex having even degree is returned.</li>
</ol>
</dd></dl>
<ol type="1">
<li>Every vertex is iteratively checked.</li>
<li>The number of edges each vertex has is checked.</li>
<li>If any vertex is found to have an odd degree the check is halted.</li>
<li>Return true if all vertices have even degree, return false otherwise. TODO refine this algorithm if possible.</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a26890ebf74d23821a6e4dbcf803b5002"></a><!-- doxytag: member="WeightedGraph::clear" ref="a26890ebf74d23821a6e4dbcf803b5002" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_weighted_graph.html#a26890ebf74d23821a6e4dbcf803b5002">WeightedGraph::clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>clear</p>
<p>Empties the <a class="el" href="class_weighted_graph.html">WeightedGraph</a> of data.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>A valid <a class="el" href="class_weighted_graph.html">WeightedGraph</a> object has been instantiated.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>The <a class="el" href="class_weighted_graph.html">WeightedGraph</a> will be emptied.</li>
</ol>
</dd></dl>
<ol type="1">
<li>The size of the data set is reduced to zero.</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="aeaea1bd5b1e14b69f2155613bfd25d68"></a><!-- doxytag: member="WeightedGraph::computePaths" ref="aeaea1bd5b1e14b69f2155613bfd25d68" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_weighted_graph.html#aeaea1bd5b1e14b69f2155613bfd25d68">WeightedGraph::computePaths</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>computePaths</p>
<p>Computes the shortest paths between the vertices of a graph and stores them in the graph's path matrix.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>*this is a valid instantiation of a <a class="el" href="class_weighted_graph.html">WeightedGraph</a></li>
<li>The adjacency matrix is in a valid state.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>The shortest (lowest cost) paths between all vertices will be computed.</li>
<li>The path costs will be stored in the path matrix.</li>
<li>No record of what the shortest paths actually are will be kept, only the resulting cost.</li>
</ol>
</dd></dl>
<p>Floyd's Algorithm is used as follows:</p>
<ol type="1">
<li>Every vertex is iteratively considered as a "mutual" neighbor.</li>
<li>Every vertex is iteratively considered for every given "mutual" vertex as a "start" vertex.</li>
<li>Every other vertex is then iteratively considered for given "mutual" and "start" vertices, as an "end" vertex.</li>
<li>A check is made for the existence of paths between the start vertex and the mutual vertex and between the mutual vertex and the end vertex.</li>
<li>If such paths exist, then the cost of traversing the two paths described in the previous step (the "indirect" path) is compared with the cost of the path directly from the start vertex to the end vertex.</li>
<li>If the indirect path is found to be cheaper than the direct one, then the direct one is replaced with the indirect one on the path matrix.</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a8079a4fb184edefad85863d915e66e9e"></a><!-- doxytag: member="WeightedGraph::getEdge" ref="a8079a4fb184edefad85863d915e66e9e" args="(const int row, const int col) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_weighted_graph.html#a8079a4fb184edefad85863d915e66e9e">WeightedGraph::getEdge</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getEdge</p>
<p>Returns the edge weight at the given position at the specified location in the adjacency matrix.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index to be searched in the path matrix. </td></tr>
    <tr><td class="paramname">col</td><td>The column index to be searched in the path matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>weight</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>*this is a valid instantiation of a <a class="el" href="class_weighted_graph.html">WeightedGraph</a>.</li>
<li>row and col are valid positions in the adjacency matrix.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>The <a class="el" href="class_weighted_graph.html">WeightedGraph</a> and all its members will remain unchanged.</li>
<li>The index of the desired entry in the 1-D representation of the adjacency matrix is returned.</li>
</ol>
</dd></dl>
<ol type="1">
<li>The indices that correspond to a 2-D matrix can be converted using the formula: (row-index * number-of-columns) + column-index.</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="ab136044e7378313087be69eb43e7f042"></a><!-- doxytag: member="WeightedGraph::getEdgeWeight" ref="ab136044e7378313087be69eb43e7f042" args="(const string &amp;v1, const string &amp;v2, int &amp;wt) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_weighted_graph.html#ab136044e7378313087be69eb43e7f042">WeightedGraph::getEdgeWeight</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>wt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const  throw ( logic_error )</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getEdgeWeight</p>
<p>Finds the edge wieght corresponding to the edge between two vertices of the given labels. The weight is then passes back by reference. true is retruned to indicate that the edge (or at least the two vertices that define it) exist in the graph. Otherwise, false is returned.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>A label for the first vertex used to define an edge. </td></tr>
    <tr><td class="paramname">v2</td><td>A label for the second vertex used to define an edge. </td></tr>
    <tr><td class="paramname">wt</td><td>The parameter used to pass back a weight of a sought edge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>result The truth value of whether an edge could be found in a graph, true if the edge does exist in the graph, false otherwise. Also indicates if the reference parameter int wt contains valid or undeterminate data.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>*this is a valid instantiation of a <a class="el" href="class_weighted_graph.html">WeightedGraph</a>.</li>
<li>The sought vertices v1 and v2 (and therefore the edge between them) should exist in the graph.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>If the edge exists in the graph, then its weight is copied into the int wt reference parameter to be passed back and true is returned.</li>
<li>Otherwise, wt will be in an undetermined state and false is returned.</li>
</ol>
</dd></dl>
<ol type="1">
<li>The vertex list is searched for verticex with lables matching the two given ones.</li>
<li>If found, their indices are used to locate the edge wait in the adjacency matrix.</li>
<li>The edge weight is copied to the reference parameter wt.</li>
<li>If either of the vertices is not found, then an exception is thrown to indicate that an invalid edge was sought.</li>
</ol>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">logic_error</td><td>Used to indicate that at least one of the given vertex labels does not exist in the graph, and therefore the edge does not exist.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a0c6d1c040128d1818ab3b38ff72723a4"></a><!-- doxytag: member="WeightedGraph::getIndex" ref="a0c6d1c040128d1818ab3b38ff72723a4" args="(const string &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_weighted_graph.html#a0c6d1c040128d1818ab3b38ff72723a4">WeightedGraph::getIndex</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getIndex</p>
<p>Retrieves the index of a vertex in the vertex list for use as a coordinate in an adjacency matrix.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A string label used a a key for finding a desired vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>result The integer index of the sought vertex in the vertex list.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>*this is a valid instantiation of a <a class="el" href="class_weighted_graph.html">WeightedGraph</a>.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>The <a class="el" href="class_weighted_graph.html">WeightedGraph</a> will remain unchanged.</li>
<li>The index of the sought vertex in the vertex list is returned.</li>
<li>If the vertex is not found, NOT_FOUND (defined in <a class="el" href="_weighted_graph_8h.html" title="Class declarations for the WeighedGraph ADT and the Vertex inner class. Utilizes both an adjacency ma...">WeightedGraph.h</a>) is returned to signal that a vertex with a label matching v was not found.</li>
</ol>
</dd></dl>
<ol type="1">
<li>A linear search is conducted to find a vertex in the vertex list with a label matching the given parameter string v.</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a8360fa50be8d2bc095b2ba69d02eb319"></a><!-- doxytag: member="WeightedGraph::getPath" ref="a8360fa50be8d2bc095b2ba69d02eb319" args="(const int row, const int col) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_weighted_graph.html#a8360fa50be8d2bc095b2ba69d02eb319">WeightedGraph::getPath</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getPath</p>
<p>Returns the path cost at the given position at the specified location in the path matrix.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index to be searched in the path matrix. </td></tr>
    <tr><td class="paramname">col</td><td>The column index to be searched in the path matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pathCost</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>*this is a valid instantiation of a <a class="el" href="class_weighted_graph.html">WeightedGraph</a>.</li>
<li>row and col are valid positions in the adjacency matrix.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>The <a class="el" href="class_weighted_graph.html">WeightedGraph</a> and all its members will remain unchanged.</li>
<li>The index of the desired entry in the 1-D representation of the adjacency matrix is returned.</li>
</ol>
</dd></dl>
<ol type="1">
<li>The indices that correspond to a 2-D matrix can be converted using the formula: (row-index * number-of-columns) + column-index.</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a60be8bab10a9142846093cb768855efd"></a><!-- doxytag: member="WeightedGraph::hasProperColoring" ref="a60be8bab10a9142846093cb768855efd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_weighted_graph.html#a60be8bab10a9142846093cb768855efd">WeightedGraph::hasProperColoring</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>hasProperColoring</p>
<p>Returns the truth value of whether or not the graph has a valid vertex coloring. true is returned if no vertex is adjacent to another vertex of same color, returns false otherwise.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>hasValidColoring The truth value of whether or not the graph has a valid vertex coloring.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>*this is a valid instantiation of a <a class="el" href="class_weighted_graph.html">WeightedGraph</a>.</li>
<li>The vertices are all colored with valid colors.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>The <a class="el" href="class_weighted_graph.html">WeightedGraph</a> will remain unchanged.</li>
<li>If the graph has a valid vertex coloring, true is returned. Otherwise, false is returned.</li>
</ol>
</dd></dl>
<ol type="1">
<li>Every vertex is checked to see if it has the same color as any neighbors.</li>
<li>If a pair of neighbors are found to have the same color, the check is halted.</li>
<li>If no pair of neighbors are found to have the same color, then true is returned.</li>
<li>If any pair of neighbors is found to have the same color, false is returned. TODO refine this algorithm if possible.</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a8be8442a104f3c411f6b1bb072fa97b1"></a><!-- doxytag: member="WeightedGraph::insertEdge" ref="a8be8442a104f3c411f6b1bb072fa97b1" args="(const string &amp;v1, const string &amp;v2, const int wt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_weighted_graph.html#a8be8442a104f3c411f6b1bb072fa97b1">WeightedGraph::insertEdge</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>wt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw ( logic_error )</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>insertEdge</p>
<p>Inserts an undirected edge of the given weight between the given vertices.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The label of the first vertex in the pair defining the edge. </td></tr>
    <tr><td class="paramname">v2</td><td>The label of the second vertex in the pair defining the edge. </td></tr>
    <tr><td class="paramname">wt</td><td>The weight of the edge to be updated or added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>*this is a properly instantiated <a class="el" href="class_weighted_graph.html">WeightedGraph</a>.</li>
<li>The graph contains at least two vertices.</li>
<li>The vertices that define the edge should be present in the graph.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>The weighted edge will be added to the graph. That is, the adjacency matrix will contain the updated/new edge weight in the two matrix locations pertaining to the given vertices (because this is not a digraph).</li>
<li>If either of the given vertex parameters are not found, then an exception of type logic_error is thrown to indicate such.</li>
</ol>
</dd></dl>
<ol type="1">
<li>The vertex list is searched for both vertices and their index is recorded.</li>
<li>The found indices are used to locate the appropriate locations in the adjacency matrix.</li>
<li>The adjacency matrix is then updated with the appropriate edge weight.</li>
<li>If either of the vertices is not found in the graph, then an exception of type logic_error is thrown to indicate that the edge cannot be added between vertices that do not exist in the graph.</li>
</ol>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">logic_error</td><td>This exception is used to report that the edge cannot be added between vertices that do not exist in the graph.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="aec4ef3455e3cc0d73a42e042adb7ac40"></a><!-- doxytag: member="WeightedGraph::insertVertex" ref="aec4ef3455e3cc0d73a42e042adb7ac40" args="(const Vertex &amp;newVertex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_weighted_graph.html#aec4ef3455e3cc0d73a42e042adb7ac40">WeightedGraph::insertVertex</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_weighted_graph_1_1_vertex.html">Vertex</a> &amp;&#160;</td>
          <td class="paramname"><em>newVertex</em></td><td>)</td>
          <td>  throw ( logic_error )</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>insertVertex</p>
<p>Adds a vertex to the graph if there is room in the list. An exception is thrown if parameter <a class="el" href="class_weighted_graph_1_1_vertex.html">Vertex</a> newVertex cannot be added. No edges are added, just a vertex.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newVertex</td><td>A new vertex to be added to the graph.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>A valid <a class="el" href="class_weighted_graph.html">WeightedGraph</a> object has been instantiated.</li>
<li>The <a class="el" href="class_weighted_graph.html">WeightedGraph</a> has not been filled to maximum capacity.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>If possible, <a class="el" href="class_weighted_graph_1_1_vertex.html">Vertex</a> newVertex is added to the end of the vertexList array member.</li>
<li>If the graph is full, an exception of type logic_error is thrown to indicate that the graph is full.</li>
</ol>
</dd></dl>
<ol type="1">
<li>If the vertexList array member is not full, then the size of the list is increased by one and the vertex is added in the last spot in the list.</li>
<li>A row of "non-edges" is then added to the adjacencyMatrix array member.</li>
<li>An edge with the weight of a loop cost is added where the new vertex intersects with itself in the matrix.</li>
<li>A column of "non_edges" is also appended to the matrix.</li>
<li>If the vertexList was full, then an exception of type logic_error is thrown to indicate that the <a class="el" href="class_weighted_graph.html">WeightedGraph</a> is full.</li>
</ol>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">logic_error</td><td>Indicates that an attempt to add a <a class="el" href="class_weighted_graph_1_1_vertex.html">Vertex</a> to a full <a class="el" href="class_weighted_graph.html">WeightedGraph</a> was made</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a1c03a0f68447cf88fed97c2076501702"></a><!-- doxytag: member="WeightedGraph::isEmpty" ref="a1c03a0f68447cf88fed97c2076501702" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_weighted_graph.html#a1c03a0f68447cf88fed97c2076501702">WeightedGraph::isEmpty</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>isEmtpy</p>
<p>Returns the truth of the emptiness of the graph, true if empty, false otherwise.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>empty The truth of the graph being empty.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>*this is a valid instantiation of a <a class="el" href="class_weighted_graph.html">WeightedGraph</a>.</li>
<li>The size member of *this is in a valid state.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>The truth of the emptiness of the graph is returned.</li>
</ol>
</dd></dl>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a22e56836e3967031a657cfa9ea5b9843"></a><!-- doxytag: member="WeightedGraph::isFull" ref="a22e56836e3967031a657cfa9ea5b9843" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_weighted_graph.html#a22e56836e3967031a657cfa9ea5b9843">WeightedGraph::isFull</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>isFull</p>
<p>Returns the truth of the fullness of the graph, true if full, false otherwise.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>full The truth of the graph being full.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>*this is a valid instantiation of a <a class="el" href="class_weighted_graph.html">WeightedGraph</a>.</li>
<li>The size member of *this is in a valid state.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>The truth of the fullness of the graph is returned.</li>
</ol>
</dd></dl>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="aa5982a507e944af28e4749cdc06543c6"></a><!-- doxytag: member="WeightedGraph::operator=" ref="aa5982a507e944af28e4749cdc06543c6" args="(const WeightedGraph &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_weighted_graph.html">WeightedGraph</a> &amp; WeightedGraph::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_weighted_graph.html">WeightedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>operator=</p>
<p>The overloaded assignment operator. Clones the data in the given parameter <a class="el" href="class_weighted_graph.html">WeightedGraph</a> other into *this.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A <a class="el" href="class_weighted_graph.html">WeightedGraph</a> to whose data will be cloned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>*this A reference to this for multiple assignments on the same line.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>Both *this and other are valid <a class="el" href="class_weighted_graph.html">WeightedGraph</a> objects.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>*this will be an equivalent object to other. All data in *this will be a clone of that in other.</li>
</ol>
</dd></dl>
<ol type="1">
<li>If the given parameter other is *this, no action is taken.</li>
<li>If <a class="el" href="class_weighted_graph.html">WeightedGraph</a> other is of different size, *this is resized.</li>
<li>The data in this is then made equivalent to that of other, size and all.</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a1db455249fa7fedf70aa5683487a17df"></a><!-- doxytag: member="WeightedGraph::removeEdge" ref="a1db455249fa7fedf70aa5683487a17df" args="(const string &amp;v1, const string &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_weighted_graph.html#a1db455249fa7fedf70aa5683487a17df">WeightedGraph::removeEdge</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw ( logic_error )</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>removeEdge</p>
<p>Removes an edge from the graph by giving it an "infinite" weight. (The "infinite" weight is the maximum integer value defined in climits)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>A label corresponding to the first vertex that defines an edge. </td></tr>
    <tr><td class="paramname">v2</td><td>A label corresponding to the second vertex that defines an edge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>*this is a valid instantiation of a <a class="el" href="class_weighted_graph.html">WeightedGraph</a>.</li>
<li>Vertices with labels corresponding to the parameters v1 and v2 should exist in the graph.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>If the edge exists in the graph, it is "removed" by giving it an "infinite" weight.</li>
<li>If either of the given vertex labels are not present in the vertex list, an exception is thrown to indicate that an invalid edge was sought.</li>
</ol>
</dd></dl>
<ol type="1">
<li>The insertEdge function is called to "remove" the edge by giving it an infinite weight. This will prevent duplication of code.</li>
<li>If the either of the vertices that define the edge can't be found, then an exception is thrown to indicate such.</li>
</ol>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">logic_error</td><td>Used to indicate that an invalid edge was chosen because at least one of the given vertex labels does not correspond to an existing vertex.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="abaaa572a9b1a60ec3cd99d8db9d9590e"></a><!-- doxytag: member="WeightedGraph::removeVertex" ref="abaaa572a9b1a60ec3cd99d8db9d9590e" args="(const string &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_weighted_graph.html#abaaa572a9b1a60ec3cd99d8db9d9590e">WeightedGraph::removeVertex</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td>  throw ( logic_error )</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>removeVertex</p>
<p>Removes a vertex from the vertex list and resizes the adjacency matrix to remove any edges that were associated with the vertex.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A label corresponding to the vertex to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>*this is a valid instantiation of a <a class="el" href="class_weighted_graph.html">WeightedGraph</a>.</li>
<li>The given label parameter should correspond to a vertex contained in the vertex list of the graph.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>The vertex corresponding to the given label will be removed.</li>
<li>Data corresponding to edges shared by the removed vertex and other vertices will be removed and the adjacency matrix will be resized appropriately.</li>
<li>The new size of the graph is updated.</li>
<li>If the given label does not correspond to a given vertex, an exception is thrown to indicate this.</li>
</ol>
</dd></dl>
<ol type="1">
<li>The sought vertex is first located in the vertex list and its index is saved.</li>
<li>The size of the graph is decremented.</li>
<li>The vertex list is then condensed by shifting all elements in the list after the removed vertex over.</li>
<li>The rows of the adjacency matrix that appear after the row corresponding to the removed vertex are moved up to replace the "removed" row.</li>
<li>The columns that appear after the one corresponding to the removed vertex are shifted left in order to replace the "removed" column.</li>
<li>If the given label is not found in the graph, an exception is thrown, indicating this.</li>
</ol>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">logic_error</td><td>Used to indicate that an attemp to remove a vertex that is not present in the graph was made.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a3afabc2236c99dac950f5161f715f114"></a><!-- doxytag: member="WeightedGraph::retrieveVertex" ref="a3afabc2236c99dac950f5161f715f114" args="(const string &amp;v, Vertex &amp;vData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_weighted_graph.html#a3afabc2236c99dac950f5161f715f114">WeightedGraph::retrieveVertex</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_weighted_graph_1_1_vertex.html">Vertex</a> &amp;&#160;</td>
          <td class="paramname"><em>vData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>retriveVertex</p>
<p>Searches the vertex list for a particular vertex label. Passes the vertex back by reference if it is found.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A string used to identify a sought vertex. </td></tr>
    <tr><td class="paramname">vData</td><td>An object of type <a class="el" href="class_weighted_graph_1_1_vertex.html">Vertex</a> intended to contain the data of the sought vertex if the vertex with a label matching the parameter label is found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>result The truth value of whether the sought vertex was found. If the vertex was found and vData contains that vertex's information, then true is returned. Otherwise, false is returned and vData is in an undetermined state.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>*this is a valid instantiation of a weighted graph.</li>
<li>vData is a properly constructed <a class="el" href="class_weighted_graph_1_1_vertex.html">Vertex</a> object.</li>
<li>A vertex with a label matching the one given as a parameter should exist in the graph.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>If a vertex with a matching label is found, then its data is copied into the given reference parameter <a class="el" href="class_weighted_graph_1_1_vertex.html">Vertex</a> vData and true is returned. Otherwise, false is returned and vData will be in an undetermined state.</li>
</ol>
</dd></dl>
<ol type="1">
<li>The vertex list is searched for a vertex with a label matching the given parameter.</li>
<li>If such a vertex is found, its data is copied to parameter <a class="el" href="class_weighted_graph_1_1_vertex.html">Vertex</a> vData and true is returned.</li>
<li>If a vertex with such a label is not found, then parameter <a class="el" href="class_weighted_graph_1_1_vertex.html">Vertex</a> vData will be in an undetermined state and false is returned.</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a9a7095848029a217a2360ca8f6fc6fc7"></a><!-- doxytag: member="WeightedGraph::setEdge" ref="a9a7095848029a217a2360ca8f6fc6fc7" args="(const int row, const int col, const int wt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_weighted_graph.html#a9a7095848029a217a2360ca8f6fc6fc7">WeightedGraph::setEdge</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>wt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>setEdge</p>
<p>Given appropriate adjacency matrix coordinates, sets the weight of the edge between two vertices.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index of the first vertex defining the edge. </td></tr>
    <tr><td class="paramname">col</td><td>The column index of the second vertex defining the edge. </td></tr>
    <tr><td class="paramname">wt</td><td>The weight the sought edge will be given.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>*this is a valid instantiation of a <a class="el" href="class_weighted_graph.html">WeightedGraph</a>.</li>
<li>Parameters row and col are valid indices corresponding to a location in the adjacency matrix.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>The location in the adjacency matrix representing the edge from the row index vertex to the column index vertex is given the parameterized weight.</li>
</ol>
</dd></dl>
<ol type="1">
<li>The indices that correspond to a 2-D matrix can be converted using the formula: (row-index * number-of-columns) + column-index.</li>
<li>The resulting index is used to set the edge's weight.</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a68788bc02a44a33289411a0d3d1da85a"></a><!-- doxytag: member="WeightedGraph::setPath" ref="a68788bc02a44a33289411a0d3d1da85a" args="(const int row, const int col, const int cost)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_weighted_graph.html#a68788bc02a44a33289411a0d3d1da85a">WeightedGraph::setPath</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>setPath</p>
<p>Given appropriate adjacency matrix coordinates, sets the cost of the path between two vertices.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index of the first vertex defining the path. </td></tr>
    <tr><td class="paramname">col</td><td>The column index of the second vertex defining the path.</td></tr>
    <tr><td class="paramname">cost</td><td>The cost the sought path will be given.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>*this is a valid instantiation of a <a class="el" href="class_weighted_graph.html">WeightedGraph</a>.</li>
<li>Parameters row and col are valid indices corresponding to a location in the path matrix.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>The location in the path matrix representing the edge from the row index vertex to the column index vertex is given the value of the parameter cost.</li>
</ol>
</dd></dl>
<ol type="1">
<li>The indices that correspond to a 2-D matrix can be converted using the formula: (row-index * number-of-columns) + column-index.</li>
<li>The resulting index is used to set the path's cost.</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="a8e6ea9adc87345052786eec67a5f9164"></a><!-- doxytag: member="WeightedGraph::showShortestPaths" ref="a8e6ea9adc87345052786eec67a5f9164" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_weighted_graph.html#a8e6ea9adc87345052786eec67a5f9164">WeightedGraph::showShortestPaths</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>showShortestPaths</p>
<p>Computes and displays the graphs path matrix.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>*this is a valid instantiation of a <a class="el" href="class_weighted_graph.html">WeightedGraph</a></li>
<li>The adjacency matrix is in a valid state.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>The <a class="el" href="class_weighted_graph.html">WeightedGraph</a> will remain unchanged.</li>
<li>The shortest (lowest cost) paths between all vertices will be re-computed.</li>
<li>The shortest path matrix will be displayed.</li>
</ol>
</dd></dl>
<ol type="1">
<li>The shortest paths are computed and stored in the pathMatrix data member.</li>
<li>Then the path matrix is displayed one row at a time.</li>
<li>If the graph is actually empty, this is stated.</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<a class="anchor" id="ad7f20a989073ea5401d504d944182347"></a><!-- doxytag: member="WeightedGraph::showStructure" ref="ad7f20a989073ea5401d504d944182347" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_weighted_graph.html#ad7f20a989073ea5401d504d944182347">WeightedGraph::showStructure</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>showStructure</p>
<p>Outputs a graph's vertex list and adjacency matrix. This operation is intended for testing/debugging purposes only.</p>
<p>PROVIDED BY THE LAB MANUAL PACKAGE</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><ol type="1">
<li>*this is a valid instantiation of a <a class="el" href="class_weighted_graph.html">WeightedGraph</a>.</li>
</ol>
</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><ol type="1">
<li>*this will remain unchanged.</li>
<li>The vertex list an adjacency matrix for the graph will be displayed.</li>
<li>The weighted graph will remain unchanged.</li>
</ol>
</dd></dl>
<ol type="1">
<li>A vertex list is displayed, both labels and colors</li>
<li>Then the adjacency matrix is displayed one row at a time.</li>
<li>If the graph is actually empty, this is stated.</li>
</ol>
<div class="fragment"><pre class="fragment"></pre></div> 
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aed50ef32c1c87bb10ca5d1bbc182880a"></a><!-- doxytag: member="WeightedGraph::adjacencyMatrix" ref="aed50ef32c1c87bb10ca5d1bbc182880a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="class_weighted_graph.html#aed50ef32c1c87bb10ca5d1bbc182880a">WeightedGraph::adjacencyMatrix</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad1854c7cf163167c7cebe7a2f5ebe9d6"></a><!-- doxytag: member="WeightedGraph::DEFAULT_COLOR" ref="ad1854c7cf163167c7cebe7a2f5ebe9d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char <a class="el" href="class_weighted_graph.html#ad1854c7cf163167c7cebe7a2f5ebe9d6">WeightedGraph::DEFAULT_COLOR</a> = 'R'<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab41b338adfc1ebc080cfca0e0b85de4b"></a><!-- doxytag: member="WeightedGraph::INFINITE_EDGE_WT" ref="ab41b338adfc1ebc080cfca0e0b85de4b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="class_weighted_graph.html#ab41b338adfc1ebc080cfca0e0b85de4b">WeightedGraph::INFINITE_EDGE_WT</a> = INT_MAX<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abc512f95c7ebf26d8984bc686f0b7bd7"></a><!-- doxytag: member="WeightedGraph::LOOP_COST" ref="abc512f95c7ebf26d8984bc686f0b7bd7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="class_weighted_graph.html#abc512f95c7ebf26d8984bc686f0b7bd7">WeightedGraph::LOOP_COST</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af9b34017e5b494cd3aca2dbc8335fc3c"></a><!-- doxytag: member="WeightedGraph::MAX_GRAPH_SIZE" ref="af9b34017e5b494cd3aca2dbc8335fc3c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="class_weighted_graph.html#af9b34017e5b494cd3aca2dbc8335fc3c">WeightedGraph::MAX_GRAPH_SIZE</a> = 10<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae8cd4e7b91702a470e59472979e94cb5"></a><!-- doxytag: member="WeightedGraph::maxSize" ref="ae8cd4e7b91702a470e59472979e94cb5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_weighted_graph.html#ae8cd4e7b91702a470e59472979e94cb5">WeightedGraph::maxSize</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aff499d450cb315d42d5bcff949f53141"></a><!-- doxytag: member="WeightedGraph::NOT_FOUND" ref="aff499d450cb315d42d5bcff949f53141" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="class_weighted_graph.html#aff499d450cb315d42d5bcff949f53141">WeightedGraph::NOT_FOUND</a> = -1<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad2e0c787899af85ebf86e9c68431c9aa"></a><!-- doxytag: member="WeightedGraph::pathMatrix" ref="ad2e0c787899af85ebf86e9c68431c9aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="class_weighted_graph.html#ad2e0c787899af85ebf86e9c68431c9aa">WeightedGraph::pathMatrix</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4452835ad9619580ff968a4d6a9cfe44"></a><!-- doxytag: member="WeightedGraph::size" ref="a4452835ad9619580ff968a4d6a9cfe44" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_weighted_graph.html#a4452835ad9619580ff968a4d6a9cfe44">WeightedGraph::size</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0893fce457ff57820d30fd050777a058"></a><!-- doxytag: member="WeightedGraph::vertexList" ref="a0893fce457ff57820d30fd050777a058" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_weighted_graph_1_1_vertex.html">Vertex</a>* <a class="el" href="class_weighted_graph.html#a0893fce457ff57820d30fd050777a058">WeightedGraph::vertexList</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/nfs/home/thenriod/Desktop/PA11/Doxy11/<a class="el" href="_weighted_graph_8h_source.html">WeightedGraph.h</a></li>
<li>/nfs/home/thenriod/Desktop/PA11/Doxy11/<a class="el" href="_weighted_graph_8cpp.html">WeightedGraph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Nov 22 2013 14:08:22 for Terence Henriod by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
