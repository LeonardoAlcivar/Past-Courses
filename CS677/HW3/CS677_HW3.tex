%===============================================================================
%=======     Document Information     ==========================================
%===============================================================================

\title{CS 677: Assignment 3}
\author{Terence Henriod}
\date{\today}
\documentclass[11pts]{article}


%===============================================================================
%=======     Packages Used     =================================================
%===============================================================================

%\usepackage{qtree}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[named]{algo}
\usepackage{verbatim}
\usepackage[right=1in,top=1in,left=1in,bottom=1in]{geometry}


%===============================================================================
%=======     Document Settings     =============================================
%===============================================================================

\setlength{\topmargin}{-1cm}
\setlength{\oddsidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.3in}


%%Currently default settings for indentation and symbols.
%%Try these by uncommenting this block!!!
%%Redefine the first level symbols
%\renewcommand{\theenumi}{\fnsymbol{enumi}-}
%\renewcommand{\labelenumi}{\theenumi}
%
%%Redefine the second level symbols
%\renewcommand{\theenumii}{\alph{enumii})}
%\renewcommand{\labelenumii}{\theenumii}
%
%%Redefine the third level symbols
%\renewcommand{\theenumiii}{\roman{enumiii}.}
%\renewcommand{\labelenumiii}{\theenumiii}
%
%%Options for redefining levels


%\arabic
%\alph 
%\Alph
%\roman
%\Roman
%\fnsymbol
%This ^^^ is all you need to change!!


%===============================================================================
%=======     User Defined Commands     =========================================
%===============================================================================

\newcommand{\BigO}[1]{\ensuremath{\operatorname{O}\bigl(#1\bigr)}}
\newcommand{\BigTheta}[1]{\ensuremath{\operatorname{\Theta}\bigl(#1\bigr)}}
\newcommand{\BigOmega}[1]{\ensuremath{\operatorname{\Omega}\bigl(#1\bigr)}}


%===============================================================================
%=======     The Document     ==================================================
%===============================================================================
\begin{document}

\maketitle

%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~     Abstract     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\begin{abstract}
In this assignment, divide and conquer algorithms are considered. One such
method for finding the max of a given set of data is considered, and
various sorting divide and conquer sorting methods are considered,
including mergesort and a 3 partition quicksort.
\end{abstract}
\newpage

% begin the problem set
\begin{enumerate}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~     Number 1     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\item Implement a Max algorithm (in C/C++) that uses a divide and conquer
strategy to find the maximum among N items stored in an array
A[0], \dots, A[n-1]. To illustrate the sequence of function calls made
by your algorithm, each call to the algorithm should print the
following tuple: \textless Return-Value, "Max(left-idx,
right-idx)" \textgreater where Return-Value
is the maximum value returned by that call and left-idx and
right-idx are the indices of the array with which that particular
recursive call is made.

  \begin{enumerate}
  %-----------------------------------------------------------------------------
  %-------     A     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item Submit your code for the algorithm. \\

  \textbf{Solution:}
    \begin{verbatim}
template <typename ItemType>
ItemType Max( ItemType* A, unsigned int left_idx, unsigned int right_idx )
{
  // variables
  ItemType Return_Value;
  ItemType left_temp;
  ItemType right_temp;
  int current_array_size = ( right_idx - left_idx + 1 );
  int left_upper_bound = 0;
  int right_lower_bound = 0;

  // base case: the current sub_array size is less than or equal to 2
  if( current_array_size == 1 )
  {
    // the only item is the greatest item
    Return_Value = A[left_idx];
  }
  // case: the current sub_array size is greater than 2
  else
  {
    // find the boundary indices of the two sub-arrays
    left_upper_bound = ( left_idx + right_idx ) / 2;
    right_lower_bound = ( ( left_idx + right_idx ) / 2 ) + 1;

    // find the max of each sub_array
    left_temp = Max( A, left_idx, left_upper_bound );
    right_temp = Max( A, right_lower_bound, right_idx );

    // find the greater of the two values
    Return_Value = ( left_temp < right_temp ? right_temp : left_temp );
  }

  // state the effect of this action for homework proposes
  cout << "<" << Return_Value << ", Max(" << left_idx << ", " << right_idx
       << ")>" << endl;

  // return the maximum value found for this array/sub-array
  return Return_Value;
}
    \end{verbatim}
\newpage

  %-----------------------------------------------------------------------------
  %-------     B     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item Submit the analysis of the running time of your algorithm. \\

  \textbf{Solution:} The running time for this algorithm can be summarized by
  the following table: \\
    \begin{center}
    \begin{tabular}{| c || c | c |}
      \hline
      Step Number & Action & Times Executed  \\
      \hline \hline
      1.          & Variable initialization and computation & $1$ \\
      \hline
      2.          & Compare the array size & $1$ \\
      \hline
      3.          & In the base case, make an assignment & $1$ \\
      \hline
      4.          & In the other case, compute the sub-array
                    bounds                                   & \BigTheta{1} \\
      \hline
      5.          & Make 2 recursive calls to find the
                    max of each sub-array              & $2 * M(\frac{n}{2})$ \\
      \hline
      6.          & Compare/assign the max of the two
                    sub-arrays                         & $1$ \\
      \hline
      7.          & Return the maximum value found     & $1$ \\
      \hline
    \end{tabular}
    \end{center}

    So it would be reasonable to say that in general this algorithm is
    representedby the recurrence: 
    \[ M(n) = 2 * M(\frac{n}{2}) + \BigTheta{1} \]
    and even more accurately by:
    \begin{equation*}
    M(x) = \left\{
          \begin{array}{rl}
          \BigTheta{1}                             & \text{if } n = 1 \\
          M(n) = 2 * M(\frac{n}{2}) + \BigTheta{1} & \text{if } n > 1
          \end{array} \right.
    \end{equation*}
    Using the "Recursion Tree" method, we can see that the problem size at
    each node will be $\frac{n}{2^{i}}$, with a constant cost at each level;
    $1 = \frac{n}{2^{i}}$
    gives $i = \lg{n}$, where $i$ is the number of recursive calls made.
    Note that at each level, the number of nodes at level $i$ is $2^i$ for
    this algortihm.
    So, summing the cost of all levels but the last one, and then adding
    the cost of the lowest level/leaves gives:
    \begin{align*}
      M(n) &= \sum_{i=0}^{\lg{n}}{1} + 2^{\lg{n}}M(1) \\
           &= \lg{n} + n * M(1) \\
           &= \BigTheta{\lg{n}} + n \\
           &= \BigTheta{\lg{n}} + \BigTheta{n} \\
      M(n) &= \BigTheta{n}
    \end{align*}

\newpage
  %-----------------------------------------------------------------------------
  %-------     C     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item Submit the output of your algorithm for the following input: \\
        A = [ T I N Y E X A M P L E ] \\

  \textbf{Solution:}
    \begin{verbatim}
Testing Problem 1 code by outputting
<Return_Value, Max(left_idx, right_idx)> tuples
=======================================================
<T, Max(0, 0)>
<I, Max(1, 1)>
<T, Max(0, 1)>
<N, Max(2, 2)>
<T, Max(0, 2)>
<Y, Max(3, 3)>
<E, Max(4, 4)>
<Y, Max(3, 4)>
<X, Max(5, 5)>
<Y, Max(3, 5)>
<Y, Max(0, 5)>
<A, Max(6, 6)>
<M, Max(7, 7)>
<M, Max(6, 7)>
<P, Max(8, 8)>
<P, Max(6, 8)>
<L, Max(9, 9)>
<E, Max(10, 10)>
<L, Max(9, 10)>
<P, Max(6, 10)>
<Y, Max(0, 10)>
    \end{verbatim}

  \end{enumerate}

\newpage
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~     Number 2     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\item Implement a bottom-up Mergesort algorithm (in C/C++) that works by
      making a sequence of passes over the entire array doing m-by-m merges,
      doubling m on each pass. For example, the algorithm first scans
      through the input performing 1-by-1 merges ot produce ordered
      sub-arrays of size 2; then, it scans through the input again performing
      2-by-2 merges to produce ordered sub-arrays of size 4, and so on until
      the entire array is sorted. At each call to Merge, print out the input
      array that is being processed by that function call. Note: the final
      Merge may be an m-by-x merge, for some x less than or equal to m
      (if the array size is a multiple of m).

  \begin{enumerate}
  %-----------------------------------------------------------------------------
  %-------     A     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item Submit your code for the algorithm. \\

  \textbf{Solution:} (Note: \textit{Merge} code adapted from
          lecture notes/textbook)
  \begin{verbatim}
template <typename ItemType>
void bottomUpMergeSort( ItemType* A, int n )
{
  // variables
  int m = 1; // the sub-array size to merge into size 2m
  int right_start = 0;
  int right_end = 0;
  int left_end = 0;

  // scan array, performing merges until two sub-arrays have been merged
  // to the original size
  while( m < n )
  {
    // perform the merge-scanning for the current sub-array size
    for( right_start = 0; right_start < n; right_start += ( 2 * m ) )
    {
      // find the end of the right sub-array
      right_end = right_start + m - 1;

      // find the end of the sub_arrays combined
      left_end = right_end + m;
      if( left_end >= n )
      {
        // prevent the end marker for the sub-arrays from overreaching the array
        left_end = n - 1;
      }

      // merge each pair of sub-arrays
      Merge( A, right_start, right_end, left_end );
    }

    // move up to the next sub-array size
    m *= 2;
  }

  // no return - void
}


template <typename ItemType>
void Merge( ItemType* A, int p, int q, int r )
{
  // variables
  int main_ndx = p;
  int left_ndx = 0;
  int right_ndx = 0;
  int left_size = q - p + 1;
  int right_size  = r - q;
  ItemType temp;
  ItemType left_array[left_size + 1];
    left_array[left_size] = kSentinel;
  ItemType right_array[right_size + 1];
    right_array[right_size] = kSentinel;

  // print the array being processed for hw purposes
  cout << "p: " << p << ", q: " << q << ", r: " << r << endl;
  cout << "Before: ";
  for( main_ndx = p; main_ndx <= r; main_ndx++ )
  {
    cout << A[main_ndx] << ' ';
  }
  cout << endl;

  // load up the sub-arrays
  for( main_ndx = p, left_ndx = 0; main_ndx <= q; left_ndx++, main_ndx++ )
  {
    // copy the element over
    left_array[left_ndx] = A[main_ndx];
  }
  for( right_ndx = 0; main_ndx <= r; right_ndx++, main_ndx++ )
  {
    // copy the element over
    right_array[right_ndx] = A[main_ndx];
  }


  // perform the merging
  for( main_ndx = p, right_ndx = 0, left_ndx = 0; main_ndx <= r; main_ndx++ )
  {
    // case: the element of the left sub-array is less or equal
    if( left_array[left_ndx] <= right_array[right_ndx] )
    {
      // store the element in the original array
      A[main_ndx] = left_array[left_ndx];

      // move on to the next element of the right sub-array
      left_ndx++;
    }
    // case: the item in the right array is the lesser of the two elements
    else
    {
      // store the element in the original array
      A[main_ndx] = right_array[right_ndx];

      // move on to the next element of the right sub-array
      right_ndx++;
    }
  }

  // print the merge result for hw purposes
  cout << "After:  ";
  for( main_ndx = p; main_ndx <= r; main_ndx++ )
  {
    cout << A[main_ndx] << ' ';
  }
  cout << endl << endl;

  // no return - void
}
  \end{verbatim}

  %-----------------------------------------------------------------------------
  %-------     B     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item Submit the output of your algorithm for the following input: \\
        A = [ A S O R T I N G E X A M P L E ] \\

  \textbf{Solution:}
  \begin{verbatim}
Testing Problem 2 code by outputting
the sub-arrays to be processed
=======================================================
p: 0, q: 0, r: 1
Before: A S 
After:  A S 

p: 2, q: 2, r: 3
Before: O R 
After:  O R 

p: 4, q: 4, r: 5
Before: T I 
After:  I T 

p: 6, q: 6, r: 7
Before: N G 
After:  G N 

p: 8, q: 8, r: 9
Before: E X 
After:  E X 

p: 10, q: 10, r: 11
Before: A M 
After:  A M 

p: 12, q: 12, r: 13
Before: P L 
After:  L P 

p: 14, q: 14, r: 14
Before: E 
After:  E 

p: 0, q: 1, r: 3
Before: A S O R 
After:  A O R S 

p: 4, q: 5, r: 7
Before: I T G N 
After:  G I N T 

p: 8, q: 9, r: 11
Before: E X A M 
After:  A E M X 

p: 12, q: 13, r: 14
Before: L P E 
After:  E L P 

p: 0, q: 3, r: 7
Before: A O R S G I N T 
After:  A G I N O R S T 

p: 8, q: 11, r: 14
Before: A E M X E L P 
After:  A E E L M P X 

p: 0, q: 7, r: 14
Before: A G I N O R S T A E E L M P X 
After:  A A E E G I L M N O P R S T X 
  \end{verbatim}

  \end{enumerate}

\newpage
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~     Number 3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\item Does the Merge procedure produce proper output if and only if the two
      input sub-arrays are in sorted order? Prove your answer, or provide a
      counterexample. \\

  \textbf{Solution:} In order to prove this, we first need to prove that Merge
  works if the sub-arrays are sorted, and will not work if they are not
  properly sorted.\\

  \textit{Merge works if sub-arrays are sorted.}\\

  \underline{Invariant}: The \emph{output array} will always remain sorted;
  any elements remaining in the \emph{sub-arrays} will be sorted and
  greater than any elements in the output array.\\

  \underline{Initialization}: When the two sub-arrays are untouched and the
  \emph{output array} is empty, then the output array is sorted because there
  are no contents to be disordered. Similarly, if only one element has been
  taken from either of the sub-arrays (the least element of the two) and
  placed in the output array, we consider this one element to be sorted; of
  course the sub-array is sorted.\\

  \underline{Maintenance}: If items are taken from the sub-arrays one at a
  time, taking the least next remaining element of the two, and adding it to the
  output array, then the output array remains sorted. Any element still
  remaining in the sub-arrays must be greater than any element that was taken
  before it (due to our assumption that the sub-arrays are sorted), along
  with only taking the least available element ensures that
  the ouput array will not have been disordered. Taking
  only the next remaining element (which will be the least remaining)
  cannot disorder a sub-array.\\

  \underline{Termination}: Once both sub-arrays are empty, they are still
  "sorted." The output array must be sorted (see the Maintenance
  Condition), an so upon termination, the output is both complete and sorted. \\

  \textit{Merge does not work if sub arrays are not sorted.}\\

  Assume that Merge still works with unsorted sub-arrays.
  Consider a case where the sub-arrays' first available element is not sorted,
  but their second available element is their least element. The remaining
  elements can be in any order. As items are transferred to the output array,
  the first items are taken, but then once the second/least elements are
  reached and placed in the output array, the output array is instantly
  unsorted. A constradiction has arisen, so we know that only having sorted
  sub-arrays enables Merge success.\\

  Thus, the Merge procedure produces proper output if and only if the
  sub-arrays are sorted.

\newpage
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~     Number 4     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\item For Quicksort, in situations where there are large numbers of
duplicate keys in the unput file, there is potential for significant
improvement of the algorithm. One solution is to partition the file into
\textbf{three} parts, one each for keys \textit{smaller than},
\textit{equal to} and \textit{larger than} the partitioning element. In
this approach the keys equal to the partitioning element that are
encountered in the left partition are kept at the partition's left end and
the keys equal to the partitioning element that are encountered in the
right partition are kept at the partition's right end. \textbf{Implement}
in C/C++ this partitioning strategy as follows: choose the pivot to be the
last element of the array. Scan the file from the left to find an element
that is not smaller than the partitioning element and from the right to
find an element that is not larger than the partitioning element, then
exchange them. If the element on the left (after the exchange) is equal
to the partitioning element, exchange it with the one at the left end of
the partition (similarly on the right). When the pointers cross, put the
partitioning element between the two partitions, then exchange all the
keys equal to it into position on either side of it (the figure on the
right (not shown) illustrates this process. During partitioning the
algorithm maintains the following situation:
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
  \hline
  equal & less & XXX & greater & equal & v \\
  \hline
\end{tabular}
\end{center}
(indices/pointers not shown)\\
Illustrate the behavior of your algorithm on the input in the above
figure by printing, after each iteration (left \& right scan and
eventual changes), the elements in the partitions as in the example
above (not shown).\\

  \begin{enumerate}
  %-----------------------------------------------------------------------------
  %-------     A     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item Submit your code for the algorithm. \\

  \textbf{Solution:}
  \begin{verbatim}
template <typename ItemType>
void threePartQuicksort( ItemType* A, int partition_start, int partition_end )
{
  // variables
  int pivot_ndx = partition_end - 1;
  int left_ndx = partition_start;
  int right_ndx = pivot_ndx - 1;
  int left_equal_ndx = left_ndx;
  int right_equal_ndx = right_ndx;
  ItemType pivot = A[pivot_ndx];

  // output the array for hw purposes
  cout << "At the start of a new call:" << endl;
  arrayPrint( A, partition_start, left_equal_ndx, left_ndx,
              right_ndx, right_equal_ndx, pivot_ndx );

  // case: the partition size is larger than 1
  if( partition_start < pivot_ndx )
  {
    // perform scanning and swapping to create the left and right partitions
    while( left_ndx < right_ndx )
    {
      // swap the two items to correctly partition them
      swap( A[left_ndx], A[right_ndx] );

      // case: the item at the left index is equal to the pivot
      //       and there is a not-equal element to swap it with
      if( ( A[left_ndx] == pivot ) && ( left_equal_ndx < left_ndx ) )
      {
        // make the swap
        swap( A[left_ndx], A[left_equal_ndx] );

        // update the left-equal sub-partition and the left partition
        left_equal_ndx++;
        left_ndx++;
      }

      // case: the item at the right index is equal to the pivot
      //       and there is a-not equal element to swap it with
      if( ( A[right_ndx] == pivot ) && ( right_ndx < right_equal_ndx ) )
      {
        // make the swap
        swap( A[right_ndx], A[right_equal_ndx] );

        // update the right-equal sub-partition and the right partition
        right_equal_ndx--;
        right_ndx--;
      }

      // scan from the left for an element that is not less than the pivot
      while( ( A[left_ndx] < pivot ) && ( left_ndx < pivot_ndx ) )
      {
        // advance the left index
        left_ndx++;
      }

      // scan from the right for an element that is not greater than the pivot
      while( ( A[right_ndx] > pivot ) && ( right_ndx > partition_start ) )
      {
        // advance the left index
        right_ndx--;
      }

      // output the array for hw purposes
      cout << "After an iteration of scan/swapping:" << endl;
      arrayPrint( A, partition_start, left_equal_ndx, left_ndx,
                  right_ndx, right_equal_ndx, pivot_ndx );
    }

    // case: the pivot is greater than all other elements in the partition
    //       (no left partition can/should be made)
    if( left_ndx < pivot_ndx )
    {
      // move the pivot to create 3 partitions: right, middle, left
      swap( A[left_ndx], A[pivot_ndx] );
      right_ndx = left_ndx - 1;
      left_ndx++;

      // bump everything from the left-equal sub-partition to the middle
      while( left_equal_ndx > partition_start )
      {
        left_equal_ndx--;
        swap( A[left_equal_ndx], A[right_ndx] );
        right_ndx--;
      }

      // bump everything from the right-equal sub-partition to the middle
      while( right_equal_ndx < pivot_ndx )
      {
        right_equal_ndx++;
        swap( A[right_equal_ndx], A[left_ndx] );
        left_ndx++;
      }
    }

    // display the effects of this function call for homework purposes
    cout << "After pivot swapping and creating the middle partition:" << endl;
    arrayPrint( A, partition_start, left_equal_ndx, left_ndx,
                right_ndx, right_equal_ndx, pivot_ndx );

    // sort the left partition
    threePartQuicksort( A, partition_start, right_ndx + 1 );

    // sort the right partition
    threePartQuicksort( A, left_ndx - 1, partition_end );
  }
  // base case: the partition was of size 1 or less
    // do nothing

  // display the effects of this function call for homework purposes
  cout << "At the end of a call:" << endl;
  arrayPrint( A, partition_start, left_equal_ndx, left_ndx,
              right_ndx, right_equal_ndx, pivot_ndx );

  // no return - void
}
  \end{verbatim}

\newpage
  %-----------------------------------------------------------------------------
  %-------     B     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item Submit the output of your algorithm for the following input: \\
        A = [ A B R A C A C A B R A B C D C ] \\

  \textbf{Solution:}
  \begin{verbatim}
Testing Problem 4 code by outputting
the array with various indices shown
=======================================================
At the start of a new call:
ABRACACABRABCDC
^            ^^
l            jr

After an iteration of scan/swapping:
DBRACACABRABCAC
^            ^^
l            jr

After an iteration of scan/swapping:
ABRACACABRABCDC
^ ^         ^^^
l i         jqr

After an iteration of scan/swapping:
CBAACACABRABRDC
^^  ^      ^ ^^
lp  i      j qr

After an iteration of scan/swapping:
CBAABACABRADRCC
^^    ^   ^ ^ ^
lp    i   j q r

After an iteration of scan/swapping:
CBAABAAABRRDCCC
^^      ^^ ^  ^
lp      ji q  r

After pivot swapping and creating the middle partition:
BBAABAAACCCCRDR
^      ^     ^^
l      j     ir

At the start of a new call:
BBAABAAA
^     ^^
l     jr

After an iteration of scan/swapping:
ABAABABA
^    ^^^
l    jqr

After an iteration of scan/swapping:
ABAABBAA
^  ^ ^ ^
l  j q r

After an iteration of scan/swapping:
ABABBAAA
^ ^ ^  ^
l j q  r

After an iteration of scan/swapping:
ABBBAAAA
^  ^   ^
l  q   r

After pivot swapping and creating the middle partition:
AAAAABBB
^    ^ ^
l    i r

At the start of a new call:




At the end of a call:




At the start of a new call:
    ABBB
    ^ ^^
    l jr

After an iteration of scan/swapping:
    BBAB
    ^ ^^
    l jr

After an iteration of scan/swapping:
    ABBB
    ^^^^
    lijr

After an iteration of scan/swapping:
    BABB
    ^^^^
    lpir

After pivot swapping and creating the middle partition:
    ABBB
    ^  ^
    l  r

At the start of a new call:
    A
    ^
    r

At the end of a call:
    A
    ^
    r

At the start of a new call:
       B
       ^
       r

At the end of a call:
       B
       ^
       r

At the end of a call:
    ABBB
    ^  ^
    l  r

At the end of a call:
AAAAABBB
^    ^ ^
l    i r

At the start of a new call:
            RDR
            ^^^
            ljr

After an iteration of scan/swapping:
            DRR
            ^^^
            lir

After pivot swapping and creating the middle partition:
            DRR
            ^ ^
            l r

At the start of a new call:
            D
            ^
            r

At the end of a call:
            D
            ^
            r

At the start of a new call:
              R
              ^
              r

At the end of a call:
              R
              ^
              r

At the end of a call:
            DRR
            ^ ^
            l r

At the end of a call:
AAAAABBBCCCCDRR
^      ^     ^^
l      j     ir
  \end{verbatim}
  \end{enumerate}

\newpage
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~     Number 5      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\item Problem 7-2 (page 186), parts (a), (c), and (d). For (c) and (d)
      assume that you have the procedure at point (b) available. \\
      \textbf{\textit{ Quicksort with equal element values }} \\
      The analysis of the expected running time of randomized quicksort in
      Section 7.4.2 assumes that all element values are distinct. In this
      problem, we examine what happens when they are not. \\
%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
% This problem was extra credit and I felt the questions were unclear,
% so these are NOT trustworthy answers
%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  \begin{enumerate}
  %-----------------------------------------------------------------------------
  %-------     A     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item Suppose that all the element values are equal. What would be
        randomized quicksort's running time in this case? \\

  \textbf{Solution:} In this case, the partitioning would not really occur.
  Since no elements would be greater than any pivot, no left partition
  could ever be formed. With no left partition ever forming, the problem size
  could only decrease by one element. In determining that only one
  element could be reduced from the problem, all other elements had to
  be visited. Thus, we get:
  \begin{align*}
    Quicksort(n) &= \sum_{i=0}^{n-1}{n-i} \\
                 &= \frac{n^{2}+n}{2} \\
    Quicksort(n) &= \BigTheta{n^{2}}
  \end{align*}

  %-----------------------------------------------------------------------------
  %-------     B     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item \textbf{Not assigned.} \\
  The PARTITION procedure returns an index $q$ such that each element of
  A[$p \dots q - 1$] is less than or equal to A[$q$] and each element
  of A[$q + 1$ \dots $r$] is greater than $q$. Modify the
  PARTITION procedure to produce a procedure
  PARTITION'[A, $p$, $r$], which permutes the elements
  of A[$p \dots r$] and returns two
  indices $q$ and $t$, where $p \le q \le t \le r$,
  such that
  \begin{itemize}
    \item all elements of A[$q \dots t$] are equal, \\
    \item each element of A[$p \dots q - 1$] is less than A[$q$], and \\
    \item each element of A[$t + 1 \dots r$] is greater than A[$q$].
  \end{itemize}
  Like PARTITION, your PARTITION' procedure should
  take \BigTheta{r - p} time. \\


  %-----------------------------------------------------------------------------
  %-------     C     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item Modify the RANDOMIZED-QUICKSORT procedure to call PARTITION', and
        call the new procedure RANDOMIZED-QUICKSORT'. Then modify the
        QUICKSORT procedure to produce a procedure QUICKSORT'(p, r) that
        calls RANDOMIZED-PARTITION' and recurses only on partitions of
        elements not known to be equal to each other. \\

  \textbf{Solution:}
  \begin{algorithm}{RANDOMIZED-QUICKSORT'}[ A( 0 \dots n-1 ), p, r ]{
    \qcomment{// Input: an array A[0 \dots n-1, 0 \dots n-1]
                        of integer numbers} }
  \qif{p $<$ r} \\
    q, t = \text{RANDOMIZED-PARTITION'}(A, p , r) \qcomment{Two returns}\\
    RANDOMIZED-QUICKSORT'(A, p, q-1) \\
    RANDOMIZED-QUICKSORT'(A, t+1, r) \\
  \qfi
  \end{algorithm}

\newpage
  \begin{algorithm}{QUICKSORT'}[ A( 0 \dots n-1 ), p, r ]{
    \qcomment{// Input: an array A[0 \dots n-1, 0 \dots n-1]
                        of integer numbers} }
  \qif{p $<$ r} \\
    q, t = \text{RANDOMIZED-PARTITION'}(A, p , r) \qcomment{Two returns} \\
    RANDOMIZED-QUICKSORT'(A, p, q-1) \\
    RANDOMIZED-QUICKSORT'(A, t+1, r) \\
  \qfi 
  \end{algorithm}

  %-----------------------------------------------------------------------------
  %-------     D     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item Using QUICKSORT', how would you adjust the analysis in 7.4.2
        to avoid the assumption that all elements are distinct? \\

  \textbf{Solution:} Because the PARTITION' procedure groups all of the
  elements with the same value of the pivot, the problem size is decreased
  by faster than typical quicksort. We can avoid the assumption that all
  elements are distinct by simply not assuming that all elements are
  distinct. Then, in the case that some elements are the same, our problem size
  is decreased by more than 1 with each recursive call. There is still
  a problem size perhaps less than $n$ at each level of the tree, but there is
  still \BigTheta{n} work at each level. The height of this tree will be
  \BigTheta{\log_{3}{n}}, which is essentially \BigTheta{\lg{n}}. While the
  asymptotic notation may not show it, the new procedure will have a better
  time complexity in what would be the original QUICKSORT's worst case,
  but a worse time complexity if all of the elements are distinct.

  \end{enumerate}

\end{enumerate}
%\LAST PAGE
\end{document}























Consider the following algorithm:
\begin{algorithm}{Enigma}[ A( 0 \dots n-1, 0 \dots n-1 ) ]{
  \qcomment{// Input: a matrix A[0 \dots n-1, 0 \dots n-1] of integer numbers} }
\qfor{ $i \qlet 0$ \qto $n - 2$ } \\
\do \\
  \qfor{ $j \qlet i + 1$ \qto $n - 1 $ } \\
  \do \\
    \qif{ $ A[i, j] \ne A[j, i] $ } \\
      \qreturn \qfalse \qfi \qrof \qrof \\
\qreturn \qtrue
\end{algorithm}

  \begin{enumerate}
  %-----------------------------------------------------------------------------
  %-------     A     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item What does this algorithm do? \\

  \textbf{Solution:} This algorithm checks to see if all of the elements
  below the main diagonal of the matrix are equal to the element that
  is transposed from the
  original element in a matrix, i.e. symmetric about, but not including,
  the diagonal. If the matrix is symmetric in this manner, this is indicated
  by the returning of true after checking all the elements. If any pair of
  elements are detected to be asymmetric, the check halts and false is
  returned. \\

  %-----------------------------------------------------------------------------
  %-------     B     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item Compute the running time of this algorithm. \\

  \textbf{Solution:} Outline the number of times each primitive operation
  (primitive math operations, comparisons, etc.) occurs, consider primitive
  operations to have constant running time. Note that $t_x$ indicates the
  number of times a statement is executed for a given value of $x$. Then sum
  the cost multiples to get the running time of the algorithm. \\

  \textit{ Numbers refer to the steps of the algorithm above.}
    \begin{center}
    \begin{tabular}{| c || c | c | c |}
      \hline
      Step Number & Cost & Times Executed (Best Case)
          & Times Executed (Worst Case)  \\
      \hline \hline
      1.          & $c_1$  & $1$ & $\sum_{i=0}^{n-2}{1} = n - 1$  \\
      \hline
      2.          & $c_2$  & $1$ & $\sum_{i=0}^{n-2}{t_i} $ \\
      \hline
      3.          & $c_3$  & $1$ & $\sum_{i=0}^{n-2}{t_i - 1}$  \\
      \hline
      4.          & $c_4$  & $1$ & $0$  \\
      \hline
      5.          & $c_5$  & $0$ & $1$  \\
      \hline
    \end{tabular}
    \end{center}

  In the "best" case scenario, the very first pair of elements A[$i,j$] and
  A[$j,i$] are not equal, thus the first for-loop check will only execute once,
  the inner for-loop check will only execute once, and the if statement will
  only execute once, and of course the return statement will return once.
  In this case, $t_i = 1$, but this will make little difference overall:
  \begin{align*}
    T(n) &= c_1(1) + c_2(1) + c_3(1) + c_4(1) + c_5(0) \\
         &= c_1 + c_2 + c_3 + c_4 \\
         &= c_a \text{(an arbitrary constant)} \\
         &= \BigTheta{1}
  \end{align*}
%  In the "best" case, this function is \BigTheta{1}.
\newpage
  In the "worst" case, both loops will execute the maximum number of times
  because each pair of elements tested will be checked before true is
  finally returned.
  In this case the value for $t_i$ will be:
  \begin{align*}
    t_i &= \sum_{j=i+1}^{n-1}{1} \\
        &= ((n - 1) - (i + 1)) + 1 \\
        &= (n - i - 2) + 1 \\
        &= n - i - 1
  \end{align*}

  So the resulting time cost is:
  \begin{align*}
    T(n) &= c_1(\sum_{i=0}^{n-2}{1}) + c_2(\sum_{i=0}^{n-2}{t_i}) +
            c_3(\sum_{i=0}^{n-2}{t_i - 1}) + c_4(0) + c_5(1) \\
         &= c_1(n - 1) + c_2(\sum_{i=0}^{n-2}{n - i - 1}) +
            c_3(\sum_{i=0}^{n-2}{(n - i - 1) - 1}) + c_5 \\
         &= c_1(n - 1) +
            c_2(\sum_{i=0}^{n-2}{n}-\sum_{i=0}^{n-2}{i}-\sum_{i=0}^{n-2}{1}) +
            c_3(\sum_{i=0}^{n-2}{n - i - 2}) + c_5 \\
         &= c_1(n - 1) +
            c_2((n - 1)(n) - (\frac{(n-1)n}{2}) - (n - 1)) +
            c_3(\sum_{i=0}^{n-2}{n}-\sum_{i=0}^{n-2}{i}-\sum_{i=0}^{n-2}{2}) +
            c_5 \\
         &= c_1(n - 1) + c_2((n^{2} - n) - (\frac{n^{2} - n}{2}) - (n - 1)) +
            c_3((n - 1)(n) - (\frac{(n-1)n}{2}) - 2(n - 1)) + c_5 \\
         &= c_1(n - 1) + c_2(\frac{n^{2} - n}{2} - (n - 1)) +
            c_3(\frac{n^{2} - n}{2} - (2n - 2)) + c_5 \\
         &= c_1(n - 1) + c_2(\frac{n^{2} - 3n + 2}{2}) +
            c_3(\frac{n^{2} - 5n + 4}{2}) + c_5 \\
         &= an^{2} + bn + c \text{, for sufficient a, b, c} \\
         &= \BigTheta{n^{2}}
  \end{align*}
  \end{enumerate}
\newpage

%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~     Number 2     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\item Solve the following recurrences using a method of your choice:
  \begin{enumerate}
  %-----------------------------------------------------------------------------
  %-------     A     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item $ T(n) = 4T(\frac{n}{3}) + n^{2} $ \\

  \textbf{Solution:} One method to use is the "Master's Method." To use this
  method, we must put the expression into the form:
  $$ T(n) = aT(\frac{n}{b}) + f(n) $$
  and then, based on which of three cases $T(n)$ and $f(n)$ fall
  into, we can make our decision:
  \begin{align*}
  \text{Case 1: } & \text{if } f(n) = \BigO{n^{\log_{b}{a-\epsilon}}}
      \text{ for some } \epsilon > 0,
      \text{ then } T(n) = \BigTheta{n^{\log_{b}{a}}} \\
  \text{Case 2: } & \text{if } f(n) = \BigTheta{n^{\log_{b}{a}}}
      \text{ then } T(n) = \BigTheta{n^{\log_{b}{a}} \lg{n}} \\
  \text{Case 3: } & \text{if } f(n) = \BigOmega{n^{\log_{b}{a+\epsilon}}}
      \text{ for some } \epsilon > 0, \\
      & \text{ and if } a*f(\frac{n}{b}) \le c*f(n)
        \text{ for some } c < 1 \text{ and all sufficiently large n, } \\
      & \text{ then } T(n) = \BigTheta{f(n)}
  \end{align*}
  By applying the Master's method to this recurrence, we have
  $a=4$, $b=3$, and $f(n) = n^{2}$, giving:
  \[ T(n) = 4T(\frac{n}{3}) + n^{2} \rightarrow n^{\log_{3}{4}}\approx
        n^{1.26} \rightarrow f(n) = \BigOmega{n^{\log_{3}{4}}} \]
  Thus, the recurrence falls under Case 3. Since it falls under case 3,
  we must ensure that the regularity condition is met:
  \begin{align*}
       a*f(\frac{n}{b}) &\le c*f(n) \text{, for all $c > 1$} \\
    (4)f(\frac{n}{(3)}) &\le c*f(n) \\
    4*(\frac{n}{3})^{2} &\le c*(n)^{2} \\
     4(\frac{n^{2}}{9}) &\le cn^{2} \\
       \frac{4}{9}n^{2} &\le cn^{2}
           \text{, }\forall c \text{ s.t. }\frac{4}{9} \le c < 1
  \end{align*}
  The regularity condition holds, so: $ T(n) = \BigTheta{n^{2}} $
  \newline
  \newpage
  %-----------------------------------------------------------------------------
  %-------     B     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item $ T(n) = T(n - 1) + 5 $ \\

  \textbf{Solution:} Using the "tree" method, we find out how many times
  the recurrence will execute before reaching its base case (problem size of
  1), and count the cost of each recursive execution. \\

  In this problem, there isn't really much of a "tree" since the recurunce
  only takes one path, but we can still use the method.

  The cost of one execution is $5 + T(n-1)$, which is a cost of $5$ per
  recurrence execution plus a constant.

  Next we must find how many times $i$ the recurrence will execute. Note
  that each time the recurrence executes, the problem size decreases by one
  until the problem size is one. So the total number of times $i$ the
  recurrence will execute is:
  \begin{align*}
    n - 1i &= 1 \\
    -i     &= 1 - n \\
    i      &= n - 1 
  \end{align*}

  Assuming that the running time of $T(1)$/$T(0)$ is constant, putting it
  all together, we get:
  \[ T(n) = 5i = 5(n-1) = \BigTheta{n} \]

  \end{enumerate}
\newpage



%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~     Number 3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\item Consider the following recursive algorithm for computing the sum
of the first $n$ cubes:
\[ S(n) = 1^{3} + 2^{3} + \ldots + n^{3} \]
\begin{algorithm}{S}[ n ]{
  \qcomment{// Input: A positive integer $n$}
  \qcomment{// Output: The sum of the first n cubes} }
\qif{$n = 1$} \\
  \qreturn $1$ \\
\qelse \\
  \qreturn $ S(n - 1) + (n * n * n) $ \qfi
\end{algorithm}

  \begin{enumerate}
  %-----------------------------------------------------------------------------
  %-------     A     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item Write and solve a recurrence relation for the number of
  multiplications made by this algorithm and solve it. \\

  \textbf{Solution:} Assuming that multiplications are primitive operations,
  we have \[ S(n) = S(n - 1) + 4 \] because the "problem size" decreases
  by one with each recursive call, and the cost incurred by each
  recursive call (other than the next recursive call) is one comparison,
  two multiplications and one addition. \\

  %-----------------------------------------------------------------------------
  %-------     B     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item How does this algorithm compare with the straightforward
  non-recursive algorithm for computing this function? \\

  \textbf{Solution:} Using the "tree" method, we can determine the running
  time for the recursive method. It clearly has a cost of 4 per recursive
  call, except for in the base case where it only has a cost of 1 comparison
  and the return of 1, i.e. a constant cost per recursice call. Since
  the "problem size" is only reduced by one with each call, and assuming that
  it will take $i$ calls to solve the problem, we find that:
  \begin{align*}
    n - 1i &= 1 \\
    -i     &= 1 - n \\
    i      &= n - 1 
  \end{align*}
  $n - 1$ calls are needed to resolve the problem. Thus, the recursive
  algorithm has running time
  \[ S(n) = ci = c(n - 1) = \BigTheta{n} \]

  As for the iterative algorithm, it would look like:
  \begin{algorithm}{S}[ n ]{
    \qcomment{// Input: A positive integer $n$}
    \qcomment{// Output: The sum of the first n cubes} }
  \qfor{$ S \qlet 0, i \qlet 0 \qto n $} \\
    \qdo{ $ S \qlet S + i^{3} $ }\qrof
  \qreturn $ S $
  \end{algorithm}

  Simple cost analysis would indicate that the loop runs $n + 1$ times,
  and the actions inside the loop run $n$ times, giving
  \[ S(n) = c_1(n + 1) + c_2(n) + c_3(1) = an + b = \BigTheta{n} 
      \text{, for sufficient $a$ and $b$ } \]

  Thus the running times are very comparable. In practice, the iterative
  algorithm would actually run faster due to the lack of overhead
  associated with recursive calls, but the two algorithms do have the same
  order of growth.

  \end{enumerate}

\newpage

%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~     Number 4     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\item Consider the following recursive algorithm:
\begin{algorithm}{Min}[ A, l, r ]{
  \qcomment{// Input: An array A[0 \dots n-1] of integer numbers}
  \qcomment{// The initial call is \textit{Min( A, 0, n-1)}} }
\qif{$l = r$} \\
  \qreturn $A[l]$ \\
\qelse{$temp1 \qlet Min(A, l, \lfloor \frac{l + r}{2} \rfloor )$} \\
       $temp2 \qlet Min(A, \lfloor \frac{l + r}{2} \rfloor + 1, r)$ \\
  \qif{$temp1 \le temp2$} \\
    \qreturn $temp1$ \\
  \qelse \\
    \qreturn $temp2$ \qfi \qfi 
\end{algorithm}

  \begin{enumerate}
  %-----------------------------------------------------------------------------
  %-------     A     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item Write the recurrence relation for the above algorithm. \\

  \textbf{Solution:} One might write the recurrence relation as follows:
  \[ M(n) = 2M(\frac{n}{2}) + c \]
  because does make some comparisons and a return with each recursive call,
  but we can also see that when further recursive calls are made, the problem
  size is halved by moving one of the indices to the median value of the
  array given for the current recursive call and passing the smaller array
  to the next recursive call. Each half of the given array is given to one
  of the two recursive calls. It should be noted that all calls to the 
  function/algorithm will generate sub-trees of equal height/size, but it
  can be reasonably said that the actual cost of the algorithm will be less
  than or equal to the running time that is found by assuming all recursive
  calls generate subtrees of precisely the same height/size. It should be
  noted that these "sub-tree" imbalances occur when integer division of an
  odd number creates a pair of unequal halves. \\

  %-----------------------------------------------------------------------------
  %-------     B     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item Solve the recurrence obtained in part (a). \\

  \textbf{Solution:} Using the tree method (appropriately this time), we
  can solve the running time of this recurrence. The cost associated with
  each recursive call is a constant plus two recursive calls (with the
  exception of base cases, which have only a constant cost). Then we
  need to compute the number of times the algorithm will run. This number,
  $i$, is found by solving the following equation: 
  \begin{align*}
    \frac{n}{2^{i}} &= 1 \\
    2^{i}           &= n \\
    i               &= \lg{n}
  \end{align*}
  So, to compute the total cost/running time of the algorithm, we have:
  \[ M(n) = ci = c(\lg{n}) = \BigTheta{\lg{n}} \]

  \end{enumerate}
\newpage

%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~     Number 5     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\item Consider the following algorithm:
\begin{algorithm}{Mystery}[ n ]{
  \qcomment{// Input: A nonnegative integer n} }
$S \qlet 0$ \\
\qfor{$i \qlet 1$ \qto $n$} \\
\qdo \\
  $S \qlet S + i * i$ \qrof \\
\qreturn $S$
\end{algorithm}

  \begin{enumerate}
  %-----------------------------------------------------------------------------
  %-------     A     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item What does this algorithm compute? \\

  \textbf{Solution:} This algorithm computes the sum of all the squares
  with roots $1$ to $n$. Every number from $1$ to $n$ is visited (step 2), each
  of those numbers are squared (step 4), and the resulting square is added
  to the running total (step 4). \\ %Prove by induction?

  %-----------------------------------------------------------------------------
  %-------     B     -----------------------------------------------------------
  %-----------------------------------------------------------------------------
  \item Compute the running time of this algorithm. \\

  \textbf{Solution:} We can begin a cost anaysis by laying out the cost and
  frequency of each step in a table:
    \begin{center}
    \begin{tabular}{| c || c | c |}
      \hline
      Step Number & Cost & Times Executed  \\
      \hline \hline
      1.          & $c_1$ & $1$ \\
      \hline
      2.          & $c_2$ & $n + 1$ \\
      \hline
      3.          & ---   & --- \\
      \hline
      4.          & $c_3$ & $n * 3$ \\
      \hline
      5.          & $c_4$ & $1$  \\
      \hline
    \end{tabular}
    \end{center}
  Which, using the values in the table to compute the running time, gives:
  \begin{align*}
    T(n) &= c_1(1) + c_2(n + 1) + c_3(3n) + c_4(1) \\
         &= an + b \\
         &= \BigTheta{n}
  \end{align*}

  \end{enumerate


